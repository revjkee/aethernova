#!/usr/bin/env python3
"""
Safe driver for core-systems health checks.
- Reads `core-systems-health-report.json` generated by a scan.
- --dry-run: print candidate commands grouped by core (default).
- --execute: only runs commands if ALLOW_EXECUTE=1 environment variable is set (safety guard).

This script intentionally does NOT run commands by default to avoid accidental side-effects.
"""
import json
import os
import shlex
import subprocess
import sys
from pathlib import Path

REPORT = Path(__file__).resolve().parents[1] / 'core-systems-health-report.json'

def load_report():
    if not REPORT.exists():
        print(f"Report not found: {REPORT}")
        sys.exit(2)
    return json.loads(REPORT.read_text())

def should_run():
    return os.environ.get('ALLOW_EXECUTE','') == '1'

def run_command(cmd, cwd=None, timeout=120):
    print(f"-> Running: {cmd} (cwd={cwd})")
    try:
        res = subprocess.run(cmd, shell=True, cwd=cwd, capture_output=True, text=True, timeout=timeout)
        print(f"Exit: {res.returncode}")
        if res.stdout:
            print("--- stdout ---")
            print(res.stdout)
        if res.stderr:
            print("--- stderr ---")
            print(res.stderr)
        return res.returncode
    except subprocess.TimeoutExpired:
        print(f"Command timed out after {timeout}s: {cmd}")
        return 124


def main():
    import argparse
    p = argparse.ArgumentParser()
    p.add_argument('--dry-run', action='store_true', default=True, dest='dry')
    p.add_argument('--execute', action='store_true', help='Run commands (requires ALLOW_EXECUTE=1)')
    p.add_argument('--filter', help='Filter cores by substring')
    args = p.parse_args()

    report = load_report()

    for core in report:
        name = core.get('name')
        if args.filter and args.filter not in name:
            continue
        cmds = core.get('candidate_commands', [])
        if not cmds:
            print(f"[{name}] no candidate commands")
            continue
        print(f"\n[{name}] candidates ({len(cmds)}):")
        for c in cmds:
            print(f"  - {c}")
        if args.execute:
            if not should_run():
                print('\nExecution prevented: set ALLOW_EXECUTE=1 to enable execution for this run')
                continue
            # Run each command sequentially
            for c in cmds:
                # safety: disallow obviously dangerous patterns
                banned = ['rm -rf', 'sudo', 'curl -sSf https://', 'ssh ']
                if any(b in c for b in banned):
                    print(f"Skipping potentially dangerous command: {c}")
                    continue
                # if command is `make -C path target`, run it with cwd at repo root
                run_command(c, timeout=300)

if __name__ == '__main__':
    main()
