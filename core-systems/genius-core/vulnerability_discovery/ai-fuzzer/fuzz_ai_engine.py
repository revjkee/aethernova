# genius-core/vulnerability-discovery/ai-fuzzer/fuzz_ai_engine.py

import random
import string
import logging

class AIFuzzer:
    """
    LLM-базированный фаззер для поиска уязвимостей в коде.
    Использует генерацию и мутации тестовых входных данных для обнаружения багов.
    """

    def __init__(self, model, mutation_rate=0.1, max_mutations=5):
        """
        :param model: объект LLM модели для генерации и анализа
        :param mutation_rate: вероятность мутации каждого символа
        :param max_mutations: максимальное количество мутаций за один тест
        """
        self.model = model
        self.mutation_rate = mutation_rate
        self.max_mutations = max_mutations
        self.logger = logging.getLogger("AIFuzzer")

    def generate_seed_input(self, length=50):
        """
        Генерирует начальный тестовый ввод случайного содержимого.
        """
        letters = string.ascii_letters + string.digits + string.punctuation + " \n\t"
        seed_input = ''.join(random.choice(letters) for _ in range(length))
        self.logger.debug(f"Generated seed input: {seed_input}")
        return seed_input

    def mutate_input(self, input_str):
        """
        Производит случайные мутации входной строки с вероятностью mutation_rate.
        """
        input_chars = list(input_str)
        mutations = 0
        for i in range(len(input_chars)):
            if mutations >= self.max_mutations:
                break
            if random.random() < self.mutation_rate:
                input_chars[i] = random.choice(string.printable)
                mutations += 1
        mutated = ''.join(input_chars)
        self.logger.debug(f"Mutated input: {mutated}")
        return mutated

    def fuzz(self, iterations=1000):
        """
        Основной цикл фаззинга.
        Генерирует начальный ввод, затем многократно мутирует и тестирует.
        """
        seed_input = self.generate_seed_input()
        current_input = seed_input

        for i in range(iterations):
            self.logger.info(f"Fuzz iteration {i + 1}")
            mutated_input = self.mutate_input(current_input)

            # Передать мутированный ввод в LLM для анализа или генерации
            result = self.model.analyze(mutated_input)

            # Логика анализа результата, выявления ошибок
            if self.detect_bug(result):
                self.logger.warning(f"Bug found on iteration {i + 1} with input: {mutated_input}")
                # Здесь можно сохранять найденные баги для дальнейшего анализа

            current_input = mutated_input

    def detect_bug(self, analysis_result):
        """
        Анализирует результат работы модели и возвращает True, если найдена уязвимость.
        """
        # Пример простой проверки на ключевые слова ошибок в выводе
        error_indicators = ["error", "exception", "crash", "fail", "vulnerability"]
        analysis_lower = analysis_result.lower()
        for indicator in error_indicators:
            if indicator in analysis_lower:
                return True
        return False
