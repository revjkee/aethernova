# genius-core/vulnerability-discovery/cve-hunter/hunter_utils.py

import re
import subprocess
import json
import logging
from typing import Optional, List, Dict

logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s %(message)s')

def run_command(command: List[str], timeout: int = 30) -> Optional[str]:
    """
    Выполнение системной команды с таймаутом и возврат stdout.
    
    :param command: Список аргументов команды, например ['nmap', '-v', 'scanme.nmap.org']
    :param timeout: Максимальное время выполнения в секундах
    :return: stdout в виде строки или None при ошибке
    """
    try:
        result = subprocess.run(
            command,
            capture_output=True,
            text=True,
            timeout=timeout,
            check=True
        )
        return result.stdout.strip()
    except subprocess.TimeoutExpired:
        logger.error(f"Команда {' '.join(command)} превысила время выполнения {timeout} секунд")
    except subprocess.CalledProcessError as e:
        logger.error(f"Ошибка при выполнении команды {' '.join(command)}: {e}")
    except Exception as e:
        logger.error(f"Неизвестная ошибка при выполнении команды {' '.join(command)}: {e}")
    return None

def extract_cve_ids(text: str) -> List[str]:
    """
    Извлечение CVE идентификаторов из текста с использованием регулярных выражений.
    
    :param text: Исходный текст
    :return: Список найденных CVE ID (уникальных)
    """
    pattern = re.compile(r'CVE-\d{4}-\d{4,7}', re.IGNORECASE)
    cve_list = pattern.findall(text)
    unique_cves = list(set([cve.upper() for cve in cve_list]))
    logger.debug(f"Извлечено CVE: {unique_cves}")
    return unique_cves

def load_json_file(filepath: str) -> Optional[Dict]:
    """
    Безопасная загрузка JSON файла.
    
    :param filepath: Путь к файлу
    :return: Словарь с данными или None в случае ошибки
    """
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        logger.error(f"Файл не найден: {filepath}")
    except json.JSONDecodeError:
        logger.error(f"Ошибка декодирования JSON в файле: {filepath}")
    except Exception as e:
        logger.error(f"Ошибка при загрузке файла {filepath}: {e}")
    return None

def save_json_file(filepath: str, data: Dict) -> bool:
    """
    Сохранение словаря в JSON файл.
    
    :param filepath: Путь для сохранения
    :param data: Данные для записи
    :return: True если успешно, False иначе
    """
    try:
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=4, ensure_ascii=False)
        return True
    except Exception as e:
        logger.error(f"Ошибка при сохранении файла {filepath}: {e}")
        return False

def normalize_text(text: str) -> str:
    """
    Очистка и нормализация текста: удаление лишних пробелов, перевод в нижний регистр.
    
    :param text: Исходный текст
    :return: Нормализованный текст
    """
    normalized = re.sub(r'\s+', ' ', text).strip().lower()
    return normalized

def is_valid_cve_id(cve_id: str) -> bool:
    """
    Проверка валидности CVE идентификатора.
    
    :param cve_id: Строка CVE
    :return: True если валиден, False иначе
    """
    return bool(re.fullmatch(r'CVE-\d{4}-\d{4,7}', cve_id, re.IGNORECASE))

def filter_cve_list(cve_list: List[str]) -> List[str]:
    """
    Фильтрация списка CVE: удаление невалидных и дубликатов, сортировка.
    
    :param cve_list: Список CVE ID
    :return: Отфильтрованный список
    """
    filtered = set()
    for cve in cve_list:
        if is_valid_cve_id(cve):
            filtered.add(cve.upper())
    return sorted(filtered)

