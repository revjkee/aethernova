# forgemind-core/exploit_forge/exploit_recipe_synth.py

import random
import logging
import hashlib
from typing import Dict, List, Optional, Any

logger = logging.getLogger("exploit_recipe_synth")
logger.setLevel(logging.DEBUG)

EXPLOIT_CLASSES = [
    "heap_overflow",
    "format_string",
    "use_after_free",
    "race_condition",
    "stack_overflow",
    "type_confusion",
    "double_free",
    "rop_chain"
]

SYNTAX_TEMPLATES = {
    "heap_overflow": [
        "allocate({size}); fill({size + offset}); overwrite({ptr}); trigger();"
    ],
    "format_string": [
        'printf(payload="%{index}$n"); trigger();'
    ],
    "use_after_free": [
        "free(obj); use(obj); trigger();"
    ],
    "race_condition": [
        "thread1: lock(resource); thread2: access(resource);"
    ],
    "stack_overflow": [
        "copy(buffer, input); input='A' * 2048 + ret_address;"
    ],
    "type_confusion": [
        "cast(obj, typeA); use_as_typeB(obj);"
    ],
    "double_free": [
        "free(obj); free(obj);"
    ],
    "rop_chain": [
        "buf = padding + rop_gadget_chain; jump(buf);"
    ]
}

class ExploitRecipe:
    def __init__(self, cls: str, template: str, metadata: Optional[Dict[str, Any]] = None):
        self.cls = cls
        self.template = template
        self.metadata = metadata or {}

    def as_dict(self) -> Dict[str, Any]:
        return {
            "class": self.cls,
            "template": self.template,
            "metadata": self.metadata
        }

    def hash_id(self) -> str:
        return hashlib.sha256(self.template.encode()).hexdigest()[:12]

class ExploitRecipeSynth:
    def __init__(self):
        self.available_classes = EXPLOIT_CLASSES
        self.syntax_templates = SYNTAX_TEMPLATES

    def generate_random(self) -> ExploitRecipe:
        cls = random.choice(self.available_classes)
        template = random.choice(self.syntax_templates[cls])
        metadata = {
            "risk": random.choice(["low", "medium", "high"]),
            "requires_sandbox": random.choice([True, False]),
            "detected": False,
            "priority": random.randint(1, 10)
        }
        recipe = ExploitRecipe(cls=cls, template=template, metadata=metadata)
        logger.info(f"[RECIPE] {cls} → {recipe.hash_id()}")
        return recipe

    def mutate_recipe(self, recipe: ExploitRecipe) -> ExploitRecipe:
        mutated = recipe.template.replace(";", ";\n").replace("trigger", "trigger_payload")
        metadata = dict(recipe.metadata)
        metadata["mutated"] = True
        return ExploitRecipe(cls=recipe.cls, template=mutated, metadata=metadata)

    def generate_batch(self, count: int = 5) -> List[ExploitRecipe]:
        batch = [self.generate_random() for _ in range(count)]
        return batch

    def validate_recipe(self, recipe: ExploitRecipe) -> bool:
        lines = recipe.template.split(";")
        valid = any("trigger" in line for line in lines)
        logger.debug(f"[VALIDATE] {recipe.hash_id()} → {valid}")
        return valid

    def export_as_json(self, recipes: List[ExploitRecipe]) -> List[Dict[str, Any]]:
        return [r.as_dict() for r in recipes]

    def generate_unique_set(self, count: int = 10) -> Dict[str, ExploitRecipe]:
        seen = {}
        while len(seen) < count:
            r = self.generate_random()
            seen[r.hash_id()] = r
        return seen
