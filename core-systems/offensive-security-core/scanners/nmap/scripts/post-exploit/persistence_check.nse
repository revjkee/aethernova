-- persistence_check.nse
--
-- Этот скрипт анализирует целевую систему на наличие признаков персистентности
-- включая планировщики задач, автозагрузку, и известные техники закрепления.
-- Работает по SSH или SMB, при наличии аутентификации.
--
-- Автор: TeslaAI Red Team
-- Лицензия: Same as Nmap

local nmap = require "nmap"
local stdnse = require "stdnse"
local string = require "string"
local shortport = require "shortport"
local smb = require "smb"
local ssh2 = require "ssh2"
local os = require "os"
local creds = require "creds"
local table = require "table"

description = [[
Проверяет наличие признаков персистентности на целевой системе.
Модуль анализирует автозагрузку (Windows/Unix), задачи cron, реестры Windows, службы, планировщики и внедрения в системные бинарники.
Поддерживает режим аудита через SMB или SSH.
]]

author = "TeslaAI Red Team"

license = "Same as Nmap"

categories = {"post-exploit", "intrusive", "auth"}

portrule = shortport.port_or_service({22, 445}, {"ssh", "microsoft-ds"})

--- Вспомогательная функция: ищем автозапуск в реестре Windows
local function check_registry_autoruns(smb_session)
  local keys = {
    "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
    "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
    "HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
  }
  local result = {}
  for _, key in ipairs(keys) do
    local val = smb_session:reg_enum(key)
    if val and #val > 0 then
      table.insert(result, "[" .. key .. "]")
      for _, line in ipairs(val) do
        table.insert(result, "  " .. line)
      end
    end
  end
  return result
end

--- Вспомогательная функция: ищем cron и systemd таймеры
local function check_unix_persistence(ssh_session)
  local cmds = {
    "cat /etc/crontab",
    "ls -1 /etc/cron.d/",
    "systemctl list-timers --all",
    "find ~/.config/autostart -type f 2>/dev/null",
    "find /etc/systemd/system/ -name '*.timer' 2>/dev/null"
  }

  local result = {}
  for _, cmd in ipairs(cmds) do
    local output = ssh_session:execute(cmd)
    if output and #output > 0 then
      table.insert(result, "# " .. cmd)
      table.insert(result, output)
    end
  end
  return result
end

--- Основной action
action = function(host, port)
  local out = {}
  local username = stdnse.get_script_args("persistence_check.user")
  local password = stdnse.get_script_args("persistence_check.pass")

  if port.number == 445 then
    local smb_session = smb.Session:new(host, username, password)
    local ok, err = smb_session:connect()
    if not ok then return "Ошибка подключения SMB: " .. err end

    stdnse.print_debug("Проверка персистентности через SMB...")
    local reg_info = check_registry_autoruns(smb_session)
    table.insert(out, "Windows Registry Autoruns:")
    table.insert(out, table.concat(reg_info, "\n"))

    smb_session:disconnect()

  elseif port.number == 22 then
    local ssh_session, err = ssh2.open(host, username, password)
    if not ssh_session then return "Ошибка подключения SSH: " .. err end

    stdnse.print_debug("Проверка персистентности через SSH...")
    local unix_info = check_unix_persistence(ssh_session)
    table.insert(out, "Unix Persistence Artifacts:")
    table.insert(out, table.concat(unix_info, "\n"))

    ssh_session:close()

  else
    return "Порт не поддерживается данным модулем"
  end

  return table.concat(out, "\n\n")
end
