# ============================================================================ #
# chronowatch-core — Production-grade Helm values
# Безопасные дефолты. Все секции опциональны и могут переопределяться per-env.
# ============================================================================ #

# --------------------------- Глобальные настройки --------------------------- #
global:
  imageRegistry: ""         # Если требуется общий реестр для всех образов
  pullSecrets: []           # e.g., ["regcred"]
  labels: {}                # Общие labels для всех объектов
  annotations: {}           # Общие аннотации для всех объектов
  podAnnotations: {}        # Общие аннотации для подов
  env: {}                   # Глобальные env (перекрываются на уровне контейнера)

# ------------------------------- Идентификаторы ----------------------------- #
nameOverride: ""
fullnameOverride: ""

# ------------------------------- Образы/Команды ---------------------------- #
image:
  repository: ghcr.io/aethernova/chronowatch-core
  tag: ""                   # По умолчанию chart.appVersion
  digest: ""                # Приоритетнее tag при указании
  pullPolicy: IfNotPresent

command: []                 # e.g., ["/bin/chronowatch"]
args: []                    # e.g., ["--config=/etc/app/config.yaml"]

# Дополнительные контейнеры
initContainers: []          # Список структур Container spec
sidecars: []                # e.g., логгер или вспомогательные агенты

# ---------------------------- Реплики и стратегия --------------------------- #
replicaCount: 3

updateStrategy:
  type: RollingUpdate
  rollingUpdate:
    maxUnavailable: 0
    maxSurge: 25%

revisionHistoryLimit: 5
terminationGracePeriodSeconds: 30
minReadySeconds: 5
progressDeadlineSeconds: 600

# ------------------------------ Сервис и порты ------------------------------ #
service:
  enabled: true
  type: ClusterIP
  annotations: {}
  labels: {}
  ports:
    - name: http
      port: 80
      targetPort: 8080
      protocol: TCP
  # Доп. порты по необходимости
  extraPorts: []            # [{name, port, targetPort, protocol}]

containerPorts:
  http: 8080
  extra: []                 # e.g., [{"name": "metrics", "containerPort": 9090}]

# ------------------------------ Probes (здоровье) --------------------------- #
livenessProbe:
  enabled: true
  httpGet:
    path: /healthz
    port: http
  initialDelaySeconds: 20
  periodSeconds: 10
  timeoutSeconds: 2
  failureThreshold: 3
  successThreshold: 1

readinessProbe:
  enabled: true
  httpGet:
    path: /readyz
    port: http
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 2
  failureThreshold: 3
  successThreshold: 1

startupProbe:
  enabled: false
  httpGet:
    path: /startupz
    port: http
  initialDelaySeconds: 0
  periodSeconds: 5
  timeoutSeconds: 2
  failureThreshold: 30

# ----------------------------- Ресурсы/лимиты ------------------------------- #
resources:
  limits:
    cpu: "500m"
    memory: "512Mi"
  requests:
    cpu: "100m"
    memory: "256Mi"

# --------------------------- Безопасность контейнера ------------------------ #
securityContext:
  enabled: true
  runAsUser: 10001
  runAsGroup: 10001
  runAsNonRoot: true
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  capabilities:
    drop: ["ALL"]
  seccompProfile:
    type: RuntimeDefault

podSecurityContext:
  enabled: true
  fsGroup: 10001
  seccompProfile:
    type: RuntimeDefault

# AppArmor аннотации (Node/дистрибутив-специфично)
apparmor:
  enabled: false
  profile: runtime/default

# ------------------------- Сервисный аккаунт/RBAC -------------------------- #
serviceAccount:
  create: true
  name: ""
  annotations: {}
  automountServiceAccountToken: false

rbac:
  create: false
  rules: []                 # Добавьте правила, если нужны доступы в API

# -------------------------------- Конфиги ----------------------------------- #
config:
  enabled: true
  # Если inline=true — генерируем ConfigMap с этими данными
  inline: true
  files:
    application.yaml: |
      server:
        port: 8080
      logging:
        level: INFO
      telemetry:
        endpoint: http://localhost:4317
  # Если inline=false — ожидаем существующие configMaps
  existingConfigMaps: []     # e.g., ["chronowatch-core-config"]

# -------------------------------- Секреты ----------------------------------- #
secrets:
  enabled: false
  inline: false
  data: {}                   # ключ -> base64
  stringData: {}             # ключ -> плейнтекст (будет base64 чарта)
  existingSecrets: []        # e.g., ["chronowatch-core-secrets"]

env:
  # Переменные окружения приложения
  # K: V или сложные источники ниже
  vars: {}
  # Ссылки на конфиги и секреты
  from:
    configMaps: []           # e.g., ["chronowatch-core-config"]
    secrets: []              # e.g., ["chronowatch-core-secrets"]

# --------------------------- Томы / Персистентность ------------------------- #
persistence:
  enabled: false
  accessModes: ["ReadWriteOnce"]
  size: 1Gi
  storageClass: ""           # пусто = default
  annotations: {}
  existingClaim: ""          # если используем уже созданный PVC
  mountPath: /var/lib/chronowatch
  subPath: ""

extraVolumes: []             # произвольные Volume
extraVolumeMounts: []        # соответствующие VolumeMount

# ------------------------------- Ingress ------------------------------------ #
ingress:
  enabled: false
  className: ""              # "nginx" | "traefik" | др.
  annotations: {}
  hosts:
    - host: chronowatch.local
      paths:
        - path: /
          pathType: Prefix
          servicePort: http
  tls: []                    # [{ secretName: tls-secret, hosts: [chronowatch.local] }]

# ---------------------------- Автомасштабирование ---------------------------- #
autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80
  behavior:
    scaleUp:
      stabilizationWindowSeconds: 30
      policies:
        - type: Percent
          value: 100
          periodSeconds: 60
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
        - type: Percent
          value: 30
          periodSeconds: 60

# ----------------------- PDB (устойчивость к сбоям) ------------------------- #
podDisruptionBudget:
  enabled: true
  minAvailable: 2
  # maxUnavailable: 1       # используйте альтернативно minAvailable

# ------------------------- Раскладка по зонам/узлам ------------------------- #
affinity:
  podAntiAffinity: "soft"    # none|soft|hard
  nodeAffinity: {}           # nodeSelectorTerms etc.

nodeSelector: {}
tolerations: []
topologySpreadConstraints:
  enabled: true
  rules:
    - maxSkew: 1
      topologyKey: topology.kubernetes.io/zone
      whenUnsatisfiable: ScheduleAnyway
      labelSelector: {}     # заполняется селектором пода чарта автоматически

# ------------------------------- Сеть/доступ -------------------------------- #
networkPolicy:
  enabled: true
  # Политики по умолчанию: deny all ingress, allow namespace egress DNS
  ingress:
    enabled: true
    fromNamespaces: []       # список ns или selector для разрешений
    fromPods: []             # labelSelector для подов-источников
    ports:
      - port: 80
        protocol: TCP
  egress:
    enabled: true
    toCIDRs:
      - "0.0.0.0/0"
    toNamespaces: []
    toPods: []
    ports:
      - port: 53
        protocol: UDP

# ------------------------------ Обсервабилити ------------------------------- #
metrics:
  enabled: true
  path: /metrics
  port: 9090
  serviceMonitor:
    enabled: true
    interval: 30s
    scrapeTimeout: 10s
    labels: {}
    annotations: {}
    honorLabels: false
  podMonitor:
    enabled: false
    interval: 30s
    scrapeTimeout: 10s
    labels: {}
    annotations: {}

alerts:
  enabled: false
  prometheusRule:
    groups:
      - name: chronowatch-core.rules
        rules:
          - alert: ChronowatchHighErrorRate
            expr: |
              sum(rate(http_server_requests_seconds_count{status=~"5.."}[5m])) 
              /
              sum(rate(http_server_requests_seconds_count[5m])) > 0.05
            for: 10m
            labels:
              severity: warning
            annotations:
              summary: "Высокая доля 5xx"
              description: "Доля 5xx > 5% за 10 минут"

# ---------------------------- Трассировка (OTEL) ---------------------------- #
opentelemetry:
  enabled: false
  exporter: otlp
  protocol: grpc              # grpc|http
  endpoint: "otel-collector:4317"
  insecure: true
  resource:
    service.name: "chronowatch-core"
  env:
    OTEL_TRACES_SAMPLER: parentbased_traceidratio
    OTEL_TRACES_SAMPLER_ARG: "0.1"

# ----------------------------- Логирование ---------------------------------- #
logging:
  level: "info"
  json: true
  # Sidecar (например, fluent-bit) — опционально
  sidecar:
    enabled: false
    image:
      repository: cr.fluentbit.io/fluent/fluent-bit
      tag: 3.0.4
      pullPolicy: IfNotPresent
    resources:
      limits:
        cpu: 100m
        memory: 128Mi
      requests:
        cpu: 20m
        memory: 64Mi
    config:
      files:
        fluent-bit.conf: |
          [SERVICE]
              Parsers_File  parsers.conf
          [INPUT]
              Name              tail
              Path              /var/log/app/*.log
              Tag               app.*
              Refresh_Interval  5
              Skip_Long_Lines   On
          [OUTPUT]
              Name  stdout
              Match *

# --------------------------- DNS, приоритет, планировщик -------------------- #
dnsPolicy: ClusterFirst
dnsConfig: {}
priorityClassName: ""
schedulerName: ""

# --------------------------- Аннотации/Лейблы POD --------------------------- #
podAnnotations:
  # Пример для прогрева sidecar-прокси или истекания кэша
  # proxy.istio.io/config: '{ "holdApplicationUntilProxyStarts": true }'
  # Аннотации с информацией о сборке/репозитории
  build.aethernova.io/commit: "{{ .Chart.AppVersion }}"
  build.aethernova.io/date: "{{ now | date \"2006-01-02T15:04:05Z07:00\" }}"

podLabels: {}

# ------------------------------- Secrets pull --------------------------------#
imagePullSecrets: []          # e.g., ["regcred"]

# ------------------------- Дополнительные манифесты ------------------------- #
extraManifests: []            # Строки YAML, которые будут применены как есть

# -------------------------- Политика конфигураций --------------------------- #
checksumConfig:
  enabled: true               # Если true — автовычисление sha256 по CM/Secret
  sources:
    - config
    - secrets

# ------------------------------ Жизненный цикл ------------------------------ #
lifecycle:
  preStop:
    enabled: true
    exec:
      command: ["/bin/sh", "-c", "sleep 5"]

# ------------------------------- Теги/SBOM ---------------------------------- #
annotations:
  sbom.aethernova.io/enabled: "true"
  sbom.aethernova.io/formats: "cyclonedx-json,spdx-json"
  vcs.ref: ""                 # можно пропатчить в CI
  vcs.branch: ""
