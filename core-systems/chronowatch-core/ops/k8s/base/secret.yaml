# =============================================================================
# ClusterSecretStore: централизованная привязка к внешнему секрет-хранилищу.
# Провайдер: HashiCorp Vault (KV v2). Аутентификация: Kubernetes ServiceAccount.
# Требования:
#  - Установлен External Secrets Operator (external-secrets.io).
#  - В Vault настроен auth method 'kubernetes' и роль, выдающая доступ к KV путям.
#  - В кластере существует ServiceAccount 'chronowatch-externalsecrets' в нужном namespace.
#  - CA Vault доступен через ConfigMap (пример: vault-ca, ключ ca.crt).
# =============================================================================
apiVersion: external-secrets.io/v1beta1
kind: ClusterSecretStore
metadata:
  name: chronowatch-cluster-store
  labels:
    app.kubernetes.io/name: chronowatch-core
    app.kubernetes.io/component: secrets
    app.kubernetes.io/part-of: chronowatch
spec:
  provider:
    vault:
      server: https://vault.example.corp:8200           # ЗАМЕНИТЕ на реальный адрес
      path: kv/chronowatch                               # KV mount path (KV v2)
      version: v2
      caProvider:
        type: ConfigMap
        name: vault-ca                                   # ConfigMap с CA
        key: ca.crt
      auth:
        # Аутентификация через Kubernetes auth method в Vault
        kubernetes:
          mountPath: kubernetes                          # путь auth backend в Vault
          role: chronowatch-core-reader                  # ЗАМЕНИТЕ на Vault Role
          serviceAccountRef:
            name: chronowatch-externalsecrets            # SA, под которым работает ESO
            namespace: default                           # ЗАМЕНИТЕ namespace при необходимости
---
# =============================================================================
# ExternalSecret: описывает какие секреты и как синхронизировать из Vault в Secret.
# Политики:
#  - refreshInterval: периодическая ротация.
#  - creationPolicy: Merge — не затирает вручную добавленные поля (если есть).
#  - deletionPolicy: Delete — удаляет Secret при удалении ExternalSecret.
# Целевой Secret:
#  - Имя: chronowatch-core-secrets
#  - Метки/аннотации: для наблюдаемости и инвентаризации.
# =============================================================================
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: chronowatch-core
  labels:
    app.kubernetes.io/name: chronowatch-core
    app.kubernetes.io/component: secrets
    app.kubernetes.io/part-of: chronowatch
spec:
  refreshInterval: 1h
  secretStoreRef:
    kind: ClusterSecretStore
    name: chronowatch-cluster-store

  # Цель синхронизации — итоговый Kubernetes Secret
  target:
    name: chronowatch-core-secrets
    creationPolicy: Merge
    deletionPolicy: Delete
    template:
      engineVersion: v2
      type: Opaque
      metadata:
        labels:
          app.kubernetes.io/name: chronowatch-core
          app.kubernetes.io/component: secrets
          security.aethernova.io/class: confidential
        annotations:
          # Аннотация для kustomize/helm чексамов: изменится — перезапустятся поды (если аннотировано на PodSpec)
          secrets.aethernova.io/checksum: "{{ .checksum }}"
          # Аннотация поддержки ротации (пример; используйте свой контроллер)
          secrets.aethernova.io/rotatedAt: "{{ now | toString }}"
      # Секция data позволяет переименовывать ключи, валидировать формат и задавать safe-defaults
      data:
        # Примеры ключей приложения/инфраструктуры
        DATABASE_URL: "{{ .db_url }}"
        REDIS_URL: "{{ .redis_url }}"
        JWT_SIGNING_KEY: "{{ .jwt_signing_key }}"
        OIDC_CLIENT_ID: "{{ .oidc_client_id }}"
        OIDC_CLIENT_SECRET: "{{ .oidc_client_secret }}"
        SENTRY_DSN: "{{ .sentry_dsn | default \"\" }}"
        # Чексумма всего секрета для триггера рестартов (не хранится в виде ключа секрета)
        # Используется только в аннотации выше
      templateFrom:
        - literal:
            name: checksum
            value: |
              {{- $vals := list .db_url .redis_url .jwt_signing_key .oidc_client_id .oidc_client_secret .sentry_dsn -}}
              {{- $j := toJson $vals -}}
              {{- $h := sha256sum $j -}}
              {{ $h }}

  # Маппинг полей из внешнего хранилища (Vault KV v2).
  # Выбирайте один из вариантов: data (по одному ключу) или dataFrom (все поля из пути).
  data:
    - secretKey: db_url
      remoteRef:
        key: prod/backend/database          # Путь в Vault (kv/chronowatch/data/prod/backend/database)
        property: DATABASE_URL              # Поле в KV v2 (data.DATABASE_URL)
        decodingStrategy: None
    - secretKey: redis_url
      remoteRef:
        key: prod/backend/redis
        property: REDIS_URL
    - secretKey: jwt_signing_key
      remoteRef:
        key: prod/security/jwt
        property: SIGNING_KEY
    - secretKey: oidc_client_id
      remoteRef:
        key: prod/security/oidc
        property: CLIENT_ID
    - secretKey: oidc_client_secret
      remoteRef:
        key: prod/security/oidc
        property: CLIENT_SECRET
    - secretKey: sentry_dsn
      remoteRef:
        key: prod/observability/sentry
        property: DSN

  # Альтернатива: подтянуть все поля сразу из одного KV-пути (раскомментируйте при необходимости)
  # dataFrom:
  #   - extract:
  #       key: prod/backend/bulk-secrets   # все поля KV попадут в Secret с теми же именами

---
# =============================================================================
# (Необязательно) ServiceAccount, под которым ESO будет запрашивать токен у Vault.
# В оверлеях можно переопределить namespace, аннотации IRSA/GCP-Workload-Identity и т.п.
# =============================================================================
apiVersion: v1
kind: ServiceAccount
metadata:
  name: chronowatch-externalsecrets
  namespace: default   # ЗАМЕНИТЕ на ваш namespace
  labels:
    app.kubernetes.io/name: chronowatch-core
    app.kubernetes.io/component: secrets
    app.kubernetes.io/part-of: chronowatch
