# neuroforge-core/ops/helm/neuroforge-core/values.yaml
# Базовые значения Helm-чарта с безопасными дефолтами и полной настраиваемостью.

# ---------------------------
# Глобальные параметры
# ---------------------------
global:
  nameOverride: ""
  fullnameOverride: ""
  imagePullSecrets: []      # [{name: regcred}]
  commonLabels: {}
  commonAnnotations: {}

  tls:
    enabled: true
    # Если secret создаётся cert-manager'ом — оставить пустым и включить ingress.tls
    secretName: ""          # пример: neuroforge-api-tls
    certManager:
      enabled: true
      clusterIssuer: letsencrypt-prod

image:
  repository: ghcr.io/your-org/neuroforge-core
  tag: "1.0.0"              # переопределяется на CI
  pullPolicy: IfNotPresent

# ---------------------------
# Реплики и стратегия обновления
# ---------------------------
replicaCount: 2

strategy:
  type: RollingUpdate
  rollingUpdate:
    maxUnavailable: 0
    maxSurge: 25%

revisionHistoryLimit: 10
minReadySeconds: 5
progressDeadlineSeconds: 600
terminationGracePeriodSeconds: 30

# ---------------------------
# Сервисный аккаунт и RBAC
# ---------------------------
serviceAccount:
  create: true
  name: ""                  # по умолчанию: {{ include "fullname" . }}
  automount: false
  annotations: {}

rbac:
  create: true
  rules: []                 # дополнительные правила при необходимости

# ---------------------------
# Безопасность пода/контейнера
# ---------------------------
podSecurityContext:
  fsGroup: 2000
  fsGroupChangePolicy: "OnRootMismatch"
  runAsNonRoot: true
  seccompProfile:
    type: RuntimeDefault

securityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  runAsUser: 1000
  runAsGroup: 1000
  capabilities:
    drop: ["ALL"]

# ---------------------------
# Контейнер приложения
# ---------------------------
command: []                 # например: ["python","-m","neuroforge.api"]
args: []                    # например: ["--config","/config/app.yaml"]

containerPorts:
  http: 8080
  metrics: 9090

env:                        # простые переменные окружения
  - name: LOG_LEVEL
    value: info

envFrom:                    # [{configMapRef:{name: ...}}, {secretRef:{name: ...}}]
  - configMapRef:
      name: ""              # пример: neuroforge-config
  - secretRef:
      name: ""              # пример: neuroforge-secrets

# ---------------------------
# Конфигурация и секреты (опционально)
# ---------------------------
config:
  enabled: false
  name: ""                  # фиксированное имя CM (иначе генерируется)
  data:                     # ключ -> содержимое
    application.yaml: |
      server:
        port: 8080

secrets:
  enabled: false
  name: ""                  # фиксированное имя Secret
  stringData: {}            # НЕ base64 (helm сам кодирует)
  data: {}                  # base64, если нужно явно

# ---------------------------
# Пробы
# ---------------------------
livenessProbe:
  enabled: true
  httpGet:
    path: /healthz/live
    port: http
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 2
  failureThreshold: 3

readinessProbe:
  enabled: true
  httpGet:
    path: /healthz/ready
    port: http
  initialDelaySeconds: 5
  periodSeconds: 5
  timeoutSeconds: 2
  failureThreshold: 3

startupProbe:
  enabled: false
  httpGet:
    path: /healthz/startup
    port: http
  failureThreshold: 30
  periodSeconds: 5

# ---------------------------
# Ресурсы
# ---------------------------
resources:
  limits:
    cpu: "1"
    memory: "1Gi"
  requests:
    cpu: "250m"
    memory: "256Mi"

# ---------------------------
# Сервис
# ---------------------------
service:
  type: ClusterIP           # ClusterIP | NodePort | LoadBalancer
  clusterIP: null
  annotations: {}
  labels: {}
  ports:
    http:
      port: 80
      targetPort: http
    metrics:
      port: 9090
      targetPort: metrics

# ---------------------------
# Ingress
# ---------------------------
ingress:
  enabled: true
  className: "nginx"
  annotations:
    cert-manager.io/cluster-issuer: "{{- if .Values.global.tls.certManager.enabled -}}{{ .Values.global.tls.certManager.clusterIssuer }}{{- end -}}"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    nginx.ingress.kubernetes.io/hsts: "true"
    nginx.ingress.kubernetes.io/hsts-max-age: "31536000"
    nginx.ingress.kubernetes.io/hsts-include-subdomains: "true"
    nginx.ingress.kubernetes.io/hsts-preload: "true"
    nginx.ingress.kubernetes.io/ssl-protocols: "TLSv1.3 TLSv1.2"
    nginx.ingress.kubernetes.io/ssl-prefer-server-ciphers: "true"
    nginx.ingress.kubernetes.io/proxy-body-size: "16m"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "120"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "120"
    nginx.ingress.kubernetes.io/limit-rps: "100"
    nginx.ingress.kubernetes.io/limit-burst: "200"
  hosts:
    - host: api.example.com
      paths:
        - path: /
          pathType: Prefix
          service:
            name: ""        # по умолчанию целевой service текущего релиза
            port: http
  tls:
    - secretName: ""        # если пусто — cert-manager создаст
      hosts:
        - api.example.com

# ---------------------------
# HPA
# ---------------------------
autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
        - type: Percent
          value: 20
          periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
        - type: Percent
          value: 100
          periodSeconds: 60

# ---------------------------
# PDB
# ---------------------------
podDisruptionBudget:
  enabled: true
  minAvailable: 1
  maxUnavailable: null
  labels: {}

# ---------------------------
# Наблюдаемость: метрики и алерты
# ---------------------------
metrics:
  enabled: true
  serviceMonitor:
    enabled: true
    namespace: ""                 # по умолчанию — релизный ns
    interval: 30s
    scrapeTimeout: 10s
    additionalLabels: {}          # например: { release: prometheus }
    scheme: http
    relabelings: []
    metricRelabelings: []
    endpoint:
      port: metrics
      path: /metrics
      honorLabels: true
  prometheusRule:
    enabled: true
    namespace: ""
    additionalLabels: {}
    groups:
      - name: neuroforge.rules
        rules:
          - alert: NeuroforgeHighErrorRate
            expr: |
              sum(rate(http_server_requests_seconds_count{status=~"5.."}[5m])) 
                / sum(rate(http_server_requests_seconds_count[5m])) > 0.05
            for: 10m
            labels: { severity: critical }
            annotations:
              summary: "Высокая доля 5xx"
              description: "Больше 5% запросов завершаются 5xx за 10m."
          - alert: NeuroforgeHighLatency
            expr: histogram_quantile(0.95, sum by (le) (rate(http_server_requests_seconds_bucket[5m]))) > 0.5
            for: 10m
            labels: { severity: warning }
            annotations:
              summary: "P95 latency > 500ms"

# ---------------------------
# Трейсинг (OTel)
# ---------------------------
tracing:
  enabled: false
  otlp:
    endpoint: "http://otel-collector:4317"
    headers: {}                   # { "x-header": "value" }
    sampler: parentbased_traceidratio
    samplerArg: "0.1"

# ---------------------------
# Логирование
# ---------------------------
logging:
  format: json
  level: info
  extraFields: {}                 # добавляемые поля (например env/region)

# ---------------------------
# Сторонние контейнеры
# ---------------------------
initContainers: []                # список объектов контейнеров
sidecars: []                      # список объектов контейнеров

# ---------------------------
# Хранилище
# ---------------------------
persistence:
  enabled: false
  storageClass: ""
  accessModes: ["ReadWriteOnce"]
  size: 10Gi
  mountPath: /data
  annotations: {}
  labels: {}

extraVolumes: []                  # произвольные volumes
extraVolumeMounts: []             # произвольные mounts

# ---------------------------
# Сетевые политики
# ---------------------------
networkPolicy:
  enabled: true
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              kubernetes.io/metadata.name: kube-system
        - podSelector: {}         # внутри namespace
      ports:
        - port: 80
          protocol: TCP
  egress:
    - to:
        - namespaceSelector: {}
      ports:
        - port: 53
          protocol: UDP           # DNS
        - port: 53
          protocol: TCP
    - to: []                      # добавить БД/кэш и т.п.
  policyTypes: ["Ingress","Egress"]

# ---------------------------
# Размещение/толерантности
# ---------------------------
nodeSelector: {}
tolerations: []
affinity:
  podAntiAffinity:
    type: soft                    # soft | hard | none
    # Шаблон для anti-affinity реализуется в шаблоне чарта

topologySpreadConstraints:
  enabled: true
  rules:
    - maxSkew: 1
      topologyKey: topology.kubernetes.io/zone
      whenUnsatisfiable: ScheduleAnyway
      labelSelector: {}           # по умолчанию — селектор приложения

priorityClassName: ""            # например: high-priority

# ---------------------------
# Доп. метки/аннотации
# ---------------------------
podAnnotations: {}
podLabels: {}
deploymentAnnotations: {}
deploymentLabels: {}

# ---------------------------
# Обновления образа
# ---------------------------
imagePullSecretsTplEnabled: false # если нужно шаблонизировать секреты

# ---------------------------
# Диагностика и отладка
# ---------------------------
hostAliases: []                   # [{ip: "10.0.0.10", hostnames: ["db.internal"]}]
dnsConfig: {}                     # { nameservers: [...], searches: [...], options: [...] }
runtimeClassName: ""              # gvisor/kata, если используется

# ---------------------------
# Endpoint /metrics отдельным сервисом (опционально)
# ---------------------------
metricsService:
  enabled: false
  annotations: {}
  labels: {}
  type: ClusterIP
  port: 9090
  targetPort: metrics
