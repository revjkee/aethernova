#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
VERSION — промышленный модуль управления версией генератора Python-кода.
Интеграция: CI/CD, SemVer, API для получения и валидации версии.

Файл используется как:
- Источник правды для версии генератора (Single Source of Truth)
- Модуль для автоматической проверки в пайплайнах
- API для систем codegen, CLI и сторонних сервисов
"""

from __future__ import annotations
import re
import json
import sys
import pathlib
from datetime import datetime
from typing import Final, Literal, TypedDict

# ----------------------------
# Конфигурация
# ----------------------------
SEMVER_REGEX: Final[re.Pattern] = re.compile(
    r"^(?P<major>0|[1-9]\d*)\."
    r"(?P<minor>0|[1-9]\d*)\."
    r"(?P<patch>0|[1-9]\d*)"
    r"(?:-(?P<prerelease>[0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?"
    r"(?:\+(?P<build>[0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?$"
)

VERSION_FILE: Final[pathlib.Path] = pathlib.Path(__file__).resolve()
METADATA_FILE: Final[pathlib.Path] = VERSION_FILE.with_name("VERSION_META.json")

# ----------------------------
# Метаданные версии
# ----------------------------
class VersionMeta(TypedDict):
    version: str
    build_date: str
    commit_hash: str
    author: str
    description: str

VERSION: Final[str] = "1.0.0"
META: VersionMeta = {
    "version": VERSION,
    "build_date": datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ"),
    "commit_hash": "UNKNOWN",  # CI подставит
    "author": "NeuroCity Codegen Core",
    "description": "Python Code Generator v1 — промышленная версия с SemVer"
}

# ----------------------------
# API функции
# ----------------------------
def get_version() -> str:
    """Возвращает текущую версию генератора."""
    return VERSION

def get_metadata() -> VersionMeta:
    """Возвращает метаданные версии."""
    return META

def validate_version(ver: str) -> bool:
    """Проверяет, соответствует ли версия стандарту SemVer."""
    return bool(SEMVER_REGEX.match(ver))

def bump_version(part: Literal["major", "minor", "patch"]) -> str:
    """Инкрементирует версию и сохраняет в файл."""
    m = SEMVER_REGEX.match(VERSION)
    if not m:
        raise ValueError(f"Invalid version format: {VERSION}")
    major, minor, patch = map(int, (m["major"], m["minor"], m["patch"]))

    if part == "major":
        major += 1
        minor = patch = 0
    elif part == "minor":
        minor += 1
        patch = 0
    elif part == "patch":
        patch += 1
    else:
        raise ValueError("Part must be one of: major, minor, patch")

    new_version = f"{major}.{minor}.{patch}"
    _update_version_file(new_version)
    return new_version

# ----------------------------
# Внутренние функции
# ----------------------------
def _update_version_file(new_version: str) -> None:
    """Обновляет VERSION и метаданные в файлах."""
    if not validate_version(new_version):
        raise ValueError(f"Invalid version format: {new_version}")

    META["version"] = new_version
    META["build_date"] = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")

    with open(VERSION_FILE, "w", encoding="utf-8") as f:
        f.write(f'VERSION = "{new_version}"\n')

    with open(METADATA_FILE, "w", encoding="utf-8") as mf:
        json.dump(META, mf, indent=4)

# ----------------------------
# CLI режим
# ----------------------------
def _cli():
    import argparse
    parser = argparse.ArgumentParser(description="VERSION manager for Python codegen")
    parser.add_argument("--get", action="store_true", help="Показать текущую версию")
    parser.add_argument("--meta", action="store_true", help="Показать метаданные")
    parser.add_argument("--validate", type=str, help="Проверить формат версии")
    parser.add_argument("--bump", choices=["major", "minor", "patch"], help="Инкрементировать версию")

    args = parser.parse_args()

    if args.get:
        print(get_version())
    elif args.meta:
        print(json.dumps(get_metadata(), indent=4))
    elif args.validate:
        print("Valid" if validate_version(args.validate) else "Invalid")
    elif args.bump:
        new_ver = bump_version(args.bump)
        print(f"Updated version to {new_ver}")
    else:
        parser.print_help()

if __name__ == "__main__":
    _cli()
