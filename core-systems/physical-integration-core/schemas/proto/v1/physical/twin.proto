// physical-integration-core/schemas/proto/v1/physical/twin.proto
syntax = "proto3";

package physical.v1;

option go_package = "github.com/aethernova/physical-integration-core/gen/physical/v1;physicalv1";
option java_multiple_files = true;
option java_package = "io.aethernova.physical.v1";
option csharp_namespace = "Aethernova.Physical.V1";
option optimize_for = SPEED;

import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/any.proto";
import "google/protobuf/field_mask.proto";
import "google/protobuf/empty.proto";
import "google/api/annotations.proto";
import "google/api/resource.proto";

// Унифицированный идентификатор ресурса Twin:
//   name: "twin/{twin_id}"
// Стабильность API: MINOR-совместимость при добавлении полей, breaking при удалении/переименовании.

// Главный ресурс цифрового двойника.
message Twin {
  option (google.api.resource) = {
    type: "aethernova.physical/Twin"
    pattern: "twin/{twin}"
  };

  // Имя ресурса формата "twin/{twin_id}".
  string name = 1;

  // Устойчивый уникальный идентификатор на стороне платформы.
  string uid = 2;

  // Версионирование состояния и ETag для оптимистичных апдейтов.
  int64 version = 3;
  string etag = 4;

  // Классификация и паспортные данные.
  string vendor = 5;
  string model = 6;
  string hw_revision = 7;
  string fw_revision = 8;
  string device_class = 9;

  // Локация и топология.
  message Geo {
    double lat = 1;
    double lon = 2;
    double alt_m = 3;
  }
  Geo geo = 10;
  string site = 11;
  string area = 12;
  string line = 13;

  // Метки и аннотации.
  map<string, string> labels = 14;
  map<string, string> annotations = 15;

  // Пользовательские атрибуты.
  google.protobuf.Struct attributes = 16;

  // Текущая жизненная стадия двойника.
  enum State {
    STATE_UNSPECIFIED = 0;
    PROVISIONING = 1;
    ACTIVE = 2;
    MAINTENANCE = 3;
    QUARANTINE = 4;
    DECOMMISSIONED = 5;
  }
  State state = 17;

  // Тени конфигурации.
  message Shadow {
    google.protobuf.Struct desired = 1;
    google.protobuf.Struct reported = 2;
    google.protobuf.Timestamp desired_ts = 3;
    google.protobuf.Timestamp reported_ts = 4;
  }
  Shadow shadow = 18;

  // Идентичность и безопасность.
  message SecurityIdentity {
    string cert_fingerprint = 1;      // SHA256 хэш клиентского сертификата
    string spiffe_id = 2;             // spiffe://...
    bool hardware_rot = 3;            // аппаратный Root of Trust
  }
  SecurityIdentity security = 19;

  // Состояние подключенности.
  enum ConnectivityState {
    CONN_STATE_UNSPECIFIED = 0;
    ONLINE = 1;
    OFFLINE = 2;
    DEGRADED = 3;
    UNKNOWN = 4;
  }
  message Connectivity {
    ConnectivityState state = 1;
    string network = 2;               // тип канала
    string ip = 3;
    string last_error = 4;
    google.protobuf.Timestamp last_seen = 5;
    uint64 rx_bytes = 6;
    uint64 tx_bytes = 7;
  }
  Connectivity connectivity = 20;

  // Временные метки.
  google.protobuf.Timestamp create_time = 21;
  google.protobuf.Timestamp update_time = 22;
  google.protobuf.Timestamp delete_time = 23;

  // Резерв для будущих обязательных полей.
  reserved 100 to 199;
  reserved "legacy_id", "owner", "group";
}

// Телеметрия.
message TelemetryEnvelope {
  // Полное имя ресурса twin, может быть пустым, если задано target_name в запросе.
  string twin_name = 1;                          // twin/{id}
  string stream = 2;                              // логический поток
  string event_id = 3;                            // уникальный id сообщения
  google.protobuf.Timestamp ts = 4;

  // Идентификация и порядковость.
  string sequence = 5;                            // монотонный счётчик или ULID
  string partition_key = 6;

  // Формат полезной нагрузки.
  string schema_uri = 7;                          // ссылка на регистрацию схемы
  string content_type = 8;                        // application/json, application/cbor

  // Данные в одном из вариантов.
  oneof payload {
    google.protobuf.Struct json = 20;
    bytes binary = 21;
    google.protobuf.Any any = 22;
  }

  // Контекст и метки.
  map<string, string> attributes = 30;
}

// Команды.
message Command {
  string id = 1;
  string type = 2;                                 // имя команды
  string target = 3;                               // датчик или исполнитель
  google.protobuf.Struct params = 4;
  google.protobuf.Timestamp ts = 5;

  enum Priority {
    PRIORITY_UNSPECIFIED = 0;
    LOW = 1;
    NORMAL = 2;
    HIGH = 3;
    CRITICAL = 4;
  }
  Priority priority = 6;

  // Таймаут для синхронного исполнения.
  google.protobuf.Duration timeout = 7;
}

message CommandResult {
  string id = 1;
  enum Status {
    STATUS_UNSPECIFIED = 0;
    ACCEPTED = 1;
    IN_PROGRESS = 2;
    COMPLETED = 3;
    REJECTED = 4;
    TIMEOUT = 5;
    FAILED = 6;
  }
  Status status = 2;
  google.protobuf.Struct output = 3;
  string message = 4;
  google.protobuf.Timestamp ts = 5;
}

// Здоровье.
message HealthStatus {
  enum State {
    HEALTH_STATE_UNSPECIFIED = 0;
    OK = 1;
    WARN = 2;
    CRIT = 3;
    UNKNOWN = 4;
  }
  State state = 1;
  // Произвольные метрики устройства.
  map<string, double> metrics = 2;
  string message = 3;
  google.protobuf.Timestamp ts = 4;
}

// Событие Twin.
message TwinEvent {
  string twin_name = 1;
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TWIN_CREATED = 1;
    TWIN_UPDATED = 2;
    TWIN_DELETED = 3;
    TELEMETRY_INGESTED = 4;
    COMMAND_STATUS = 5;
    HEALTH_CHANGED = 6;
    CONNECTIVITY_CHANGED = 7;
    SHADOW_DESIRED_UPDATED = 8;
    SHADOW_REPORTED_UPDATED = 9;
  }
  Type type = 2;
  google.protobuf.Timestamp ts = 3;
  oneof data {
    Twin twin = 10;
    TelemetryEnvelope telemetry = 11;
    CommandResult command_result = 12;
    HealthStatus health = 13;
  }
  string etag = 20;
}

// CRUD и операции служебного сервиса Twin.
service TwinService {
  // Создать Twin.
  rpc CreateTwin(CreateTwinRequest) returns (Twin) {
    option (google.api.http) = {
      post: "/v1/twins"
      body: "twin"
    };
  }

  // Получить Twin.
  rpc GetTwin(GetTwinRequest) returns (Twin) {
    option (google.api.http) = {
      get: "/v1/{name=twin/*}"
    };
  }

  // Список Twin с фильтрацией и пагинацией.
  rpc ListTwins(ListTwinsRequest) returns (ListTwinsResponse) {
    option (google.api.http) = {
      get: "/v1/twins"
    };
  }

  // Полное обновление.
  rpc UpdateTwin(UpdateTwinRequest) returns (Twin) {
    option (google.api.http) = {
      patch: "/v1/{twin.name=twin/*}"
      body: "twin"
    };
  }

  // Частичный патч по FieldMask.
  rpc PatchTwin(PatchTwinRequest) returns (Twin) {
    option (google.api.http) = {
      patch: "/v1/{name=twin/*}:patch"
      body: "twin"
    };
  }

  // Удаление.
  rpc DeleteTwin(DeleteTwinRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v1/{name=twin/*}"
    };
  }

  // Публикация телеметрии батчем.
  rpc PublishTelemetry(PublishTelemetryRequest) returns (PublishTelemetryResponse) {
    option (google.api.http) = {
      post: "/v1/{name=twin/*}:publishTelemetry"
      body: "*"
    };
  }

  // Двунаправленный поток телеметрии.
  rpc StreamTelemetry(stream TelemetryUpstream) returns (stream TelemetryDownstream);

  // Отправка команды.
  rpc SendCommand(SendCommandRequest) returns (SendCommandResponse) {
    option (google.api.http) = {
      post: "/v1/{name=twin/*}:sendCommand"
      body: "*"
    };
  }

  // Подтверждение и финальный статус команды.
  rpc AckCommand(AckCommandRequest) returns (AckCommandResponse) {
    option (google.api.http) = {
      post: "/v1/{name=twin/*}:ackCommand"
      body: "*"
    };
  }

  // Отчёт о здоровье.
  rpc ReportHealth(ReportHealthRequest) returns (ReportHealthResponse) {
    option (google.api.http) = {
      post: "/v1/{name=twin/*}:reportHealth"
      body: "*"
    };
  }

  // Подписка на события Twin.
  rpc WatchEvents(WatchEventsRequest) returns (stream TwinEvent) {
    option (google.api.http) = {
      get: "/v1/{name=twin/*}:watchEvents"
    };
  }

  // Пакетное обновление Twins.
  rpc BatchUpdateTwins(BatchUpdateTwinsRequest) returns (BatchUpdateTwinsResponse) {
    option (google.api.http) = {
      post: "/v1/twins:batchUpdate"
      body: "*"
    };
  }
}

// Запросы и ответы CRUD.
message CreateTwinRequest {
  // Родительская коллекция, опционально, если используется многотенантность:
  // "projects/{project}/sites/{site}" и т.п. Для простых сценариев может быть пустым.
  string parent = 1;
  Twin twin = 2;
  string twin_id = 3; // часть имени ресурса, если не задана, генерируется.
}

message GetTwinRequest {
  string name = 1; // twin/{twin_id}
}

message ListTwinsRequest {
  string parent = 1;
  int32 page_size = 2;
  string page_token = 3;

  // Фильтры. Примеры:
  // filter: "state=ACTIVE AND labels.line='A'"
  string filter = 4;

  // Сортировка. Пример:
  // order_by: "update_time desc"
  string order_by = 5;

  // Быстрая фильтрация по меткам.
  map<string, string> labels_match = 6;
}

message ListTwinsResponse {
  repeated Twin twins = 1;
  string next_page_token = 2;
}

message UpdateTwinRequest {
  Twin twin = 1;
  google.protobuf.FieldMask update_mask = 2;
  bool allow_missing = 3; // создать при отсутствии
  string if_match = 4;    // ETag для оптимистичной блокировки
}

message PatchTwinRequest {
  string name = 1;                       // twin/{twin_id}
  Twin twin = 2;                         // патч-данные
  google.protobuf.FieldMask update_mask = 3;
  string if_match = 4;                   // условие по ETag
}

message DeleteTwinRequest {
  string name = 1;
  bool allow_missing = 2;
  bool force = 3;
}

// Телеметрия RPC.
message PublishTelemetryRequest {
  string name = 1; // twin/{twin_id}
  repeated TelemetryEnvelope envelopes = 2;
}

message PublishTelemetryResponse {
  // Подтверждения по event_id.
  map<string, Ack> acks = 1;

  message Ack {
    enum Status {
      ACK_STATUS_UNSPECIFIED = 0;
      ACCEPTED = 1;
      REJECTED = 2;
      DUPLICATE = 3;
      INVALID_SCHEMA = 4;
      RATE_LIMITED = 5;
      INTERNAL_ERROR = 6;
    }
    Status status = 1;
    string message = 2;
  }
}

// Потоки телеметрии.
message TelemetryUpstream {
  string name = 1; // twin/{twin_id}
  TelemetryEnvelope envelope = 2;
}

message TelemetryDownstream {
  // Подтверждение и возможные управляющие сигналы пайплайна.
  string event_id = 1;
  PublishTelemetryResponse.Ack ack = 2;
  // Сигналы управления, например смена QoS или окна.
  map<string, string> control = 3;
}

// Командные RPC.
message SendCommandRequest {
  string name = 1;            // twin/{twin_id}
  Command command = 2;
  bool synchronous = 3;       // true для ожидания результата до timeout
}

message SendCommandResponse {
  CommandResult result = 1;   // при synchronous=true
  string async_command_id = 2;// при synchronous=false
}

message AckCommandRequest {
  string name = 1;            // twin/{twin_id}
  string command_id = 2;
  CommandResult.Status status = 3;
  string message = 4;
  google.protobuf.Struct output = 5;
}

message AckCommandResponse {
  CommandResult result = 1;
}

// Здоровье RPC.
message ReportHealthRequest {
  string name = 1;            // twin/{twin_id}
  HealthStatus health = 2;
}

message ReportHealthResponse {
  HealthStatus.State state = 1;
  string message = 2;
}

// Подписка на события.
message WatchEventsRequest {
  string name = 1;            // twin/{twin_id} или "-" для всех
  // Фильтр по типам событий и по времени.
  repeated TwinEvent.Type types = 2;
  google.protobuf.Timestamp since = 3;
}

// Пакетные обновления.
message BatchUpdateTwinsRequest {
  repeated UpdateTwinRequest updates = 1;
  bool atomic = 2; // при true все или ничего
}

message BatchUpdateTwinsResponse {
  repeated Twin results = 1;
  // При partial success atomic=false заполняется errors в том же порядке.
  repeated Error errors = 2;

  message Error {
    int32 index = 1;
    int32 code = 2; // например HTTP code
    string message = 3;
  }
}
