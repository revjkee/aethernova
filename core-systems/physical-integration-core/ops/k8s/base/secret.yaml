# physical-integration-core/ops/k8s/base/secret.yaml
# Strategy A (RECOMMENDED): External Secrets Operator — секреты из внешнего менеджера (AWS/GCP/Vault)
# Требует установленный CRD ExternalSecret + SecretStore/ClusterSecretStore.
# Документация: https://external-secrets.io
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: physical-integration-core
  labels:
    app.kubernetes.io/name: physical-integration-core
    app.kubernetes.io/instance: physical-integration-core
    app.kubernetes.io/part-of: physical-integration-core
    app.kubernetes.io/component: api
    app.kubernetes.io/managed-by: kustomize
  annotations:
    # Включает автоматический пересозданий целевого Secret при изменении провайдера
    external-secrets.io/replication-interval: "1h"
spec:
  refreshInterval: 1h
  secretStoreRef:
    # Используйте ClusterSecretStore для cross-namespace, иначе SecretStore в текущем namespace
    kind: ClusterSecretStore
    name: cluster-secrets
  target:
    name: physical-integration-core
    creationPolicy: Owner
    deletionPolicy: Retain
    template:
      type: Opaque
      metadata:
        labels:
          app.kubernetes.io/name: physical-integration-core
          app.kubernetes.io/instance: physical-integration-core
          app.kubernetes.io/part-of: physical-integration-core
          app.kubernetes.io/component: api
          app.kubernetes.io/managed-by: external-secrets
        annotations:
          # Помечаем, что secret не должен логироваться/дампиться
          security.openshift.io/internal: "true"
      # Устанавливаем immutable через пост-рендер (см. ниже Strategy C) или через контроллер (если поддерживается)
  data:
    # Ключи в внешнем хранилище → ключи в Kubernetes Secret
    - secretKey: DATABASE_URL
      remoteRef:
        key: prod/physical-integration-core/DATABASE_URL
        decodingStrategy: None
    - secretKey: API_KEY
      remoteRef:
        key: prod/physical-integration-core/API_KEY
    - secretKey: APP_CONFIG
      remoteRef:
        key: prod/physical-integration-core/APP_CONFIG
        # Пример: хранится как JSON в менеджере секретов, попадёт строкой
---
# Strategy B: SealedSecret — безопасное хранение зашифрованного секрета в Git
# Требует установленный Sealed Secrets Controller (bitnami-labs). Зашифруйте значения через kubeseal.
# Документация: https://github.com/bitnami-labs/sealed-secrets
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: physical-integration-core
  labels:
    app.kubernetes.io/name: physical-integration-core
    app.kubernetes.io/instance: physical-integration-core
    app.kubernetes.io/part-of: physical-integration-core
    app.kubernetes.io/component: api
    app.kubernetes.io/managed-by: sealed-secrets
spec:
  template:
    metadata:
      name: physical-integration-core
      labels:
        app.kubernetes.io/name: physical-integration-core
        app.kubernetes.io/instance: physical-integration-core
        app.kubernetes.io/part-of: physical-integration-core
        app.kubernetes.io/component: api
        app.kubernetes.io/managed-by: sealed-secrets
      annotations:
        # Поддержка sidecar/perf меток при необходимости
        checksum/config: "sha256:REPLACE_WITH_CONFIG_CHECKSUM"
    type: Opaque
    # Начиная с k8s 1.21 поддерживается immutable
    immutable: true
  encryptedData:
    # Вставьте вывод kubeseal --format yaml для каждого ключа.
    # Пример значения ниже — заполнитель, заменить реальными ciphertext.
    DATABASE_URL: AgAABA...REPLACE_WITH_CIPHERTEXT...
    API_KEY: AgAABA...REPLACE_WITH_CIPHERTEXT...
    APP_CONFIG: AgAABA...REPLACE_WITH_CIPHERTEXT...
---
# Strategy C: Plain Secret (fallback) — используется только для локалки/стейджинга без менеджера секретов.
# Значения задаются через kustomize patches/secretGenerator или CI инъекцией.
apiVersion: v1
kind: Secret
metadata:
  name: physical-integration-core
  labels:
    app.kubernetes.io/name: physical-integration-core
    app.kubernetes.io/instance: physical-integration-core
    app.kubernetes.io/part-of: physical-integration-core
    app.kubernetes.io/component: api
    app.kubernetes.io/managed-by: kustomize
  annotations:
    # Запрет на включение секрета в аварийные дампы (если поддерживается платформой)
    backup.velero.io/backup-volumes-excludes: "true"
type: Opaque
immutable: true
stringData:
  # ВНИМАНИЕ: не коммитите реальные значения в Git. Для prod/stage используйте Strategy A или B.
  DATABASE_URL: "postgresql://user:pass@db:5432/physical_integration?sslmode=require"
  API_KEY: "replace-me"
  # Пример сложной конфигурации как JSON, которую приложение парсит в runtime
  APP_CONFIG: |
    {
      "feature_flags": {
        "enable_batch_ingest": true,
        "strict_schema": true
      },
      "ingress": {
        "rate_limit_rps": 100
      }
    }
