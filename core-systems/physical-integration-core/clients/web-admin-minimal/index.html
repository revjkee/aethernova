<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <title>Physical Integration Core · Admin</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <!-- В проде выставляйте CSP заголовком на уровне reverse proxy (nonce/hashes).
       Здесь используем консервативный meta-CSP для статики. -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="referrer" content="same-origin">
  <meta name="color-scheme" content="light dark">
  <meta name="theme-color" content="#0f172a">
  <style>
    :root{
      --bg: #0b1020;
      --panel:#0f172a;
      --text:#e5e7eb;
      --muted:#94a3b8;
      --ok:#10b981;
      --warn:#f59e0b;
      --err:#ef4444;
      --accent:#38bdf8;
      --border:#1f2937;
      --chip:#111827;
    }
    @media (prefers-color-scheme: light){
      :root{
        --bg:#f8fafc; --panel:#ffffff; --text:#0f172a; --muted:#475569;
        --ok:#047857; --warn:#b45309; --err:#b91c1c; --accent:#0369a1; --border:#e2e8f0; --chip:#e5e7eb;
      }
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
      background:var(--bg); color:var(--text);
    }
    header{
      position:sticky; top:0; z-index:10; backdrop-filter:saturate(1.1) blur(6px);
      background: color-mix(in oklab, var(--panel) 85%, transparent);
      border-bottom:1px solid var(--border);
    }
    .wrap{max-width:1200px; margin:0 auto; padding:12px 16px}
    .row{display:flex; gap:12px; align-items:center; flex-wrap:wrap}
    .grow{flex:1 1 auto}
    .brand{font-weight:600; letter-spacing:.2px}
    .env{font-size:12px; padding:2px 8px; border-radius:999px; background:var(--chip); border:1px solid var(--border)}
    .controls{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    input,button,select{
      background:var(--panel); color:var(--text); border:1px solid var(--border); border-radius:8px; padding:8px 10px;
    }
    input::placeholder{color:var(--muted)}
    button{cursor:pointer}
    button.primary{background:var(--accent); color:#fff; border-color: color-mix(in oklab, var(--accent) 60%, #000 40%)}
    main{max-width:1200px; margin:16px auto; padding:0 16px}
    .grid{display:grid; grid-template-columns:repeat(12,1fr); gap:16px}
    .card{
      grid-column: span 12;
      background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:14px;
      box-shadow:0 0 0 1px rgba(0,0,0,.02), 0 10px 20px rgba(0,0,0,.08);
    }
    @media(min-width:900px){
      .span-4{grid-column: span 4}
      .span-6{grid-column: span 6}
      .span-8{grid-column: span 8}
    }
    .title{font-weight:600; margin:0 0 8px 0}
    .muted{color:var(--muted)}
    .kvs{display:grid; grid-template-columns: max-content 1fr; gap:6px 10px; align-items:center}
    .kvs div.key{color:var(--muted)}
    .status{display:inline-flex; align-items:center; gap:6px; font-weight:600}
    .dot{width:10px;height:10px;border-radius:50%}
    .ok{background:var(--ok)} .warn{background:var(--warn)} .err{background:var(--err)}
    code,pre{font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace; font-size:12px}
    pre{background:color-mix(in oklab, var(--panel) 90%, #000 10%); border:1px dashed var(--border); border-radius:10px; padding:10px; overflow:auto; max-height:260px}
    table{width:100%; border-collapse:collapse; font-size:13px}
    th,td{padding:8px 6px; border-bottom:1px solid var(--border); text-align:left}
    th{color:var(--muted); font-weight:600}
    .chip{font-size:12px; padding:2px 8px; border-radius:999px; background:var(--chip); border:1px solid var(--border)}
    .right{margin-left:auto}
    .small{font-size:12px}
    .sr-only{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); border:0}
  </style>
</head>
<body>
  <header>
    <div class="wrap row" role="navigation" aria-label="Основная панель администратора">
      <div class="brand">Physical Integration Core</div>
      <span id="envChip" class="env" aria-live="polite">env: prod</span>
      <span id="versionChip" class="env">v0.0.0</span>
      <div class="grow"></div>
      <div class="controls" role="group" aria-label="Параметры подключения">
        <input id="apiBase" type="url" placeholder="https://api.example.com" size="28" aria-label="API Base URL">
        <input id="token" type="password" placeholder="Bearer token (не сохраняется)" size="24" aria-label="Токен">
        <button id="saveBase" class="primary" title="Сохранить API Base">Сохранить</button>
        <button id="clearToken" title="Очистить токен">Сбросить токен</button>
        <label class="small" for="themeToggle">
          <input id="themeToggle" type="checkbox"> Темная тема
        </label>
      </div>
    </div>
  </header>

  <main>
    <section class="grid" aria-label="Сводка">
      <article class="card span-6" aria-labelledby="statusTitle">
        <h2 id="statusTitle" class="title">Статус сервиса</h2>
        <div class="kvs">
          <div class="key">Health</div>
          <div><span id="healthBadge" class="status"><span class="dot warn"></span><span id="healthText">Проверка…</span></span></div>

          <div class="key">Версия</div>
          <div><span id="version" class="chip">—</span></div>

          <div class="key">Аптайм</div>
          <div><span id="uptime">—</span></div>

          <div class="key">Время сервера</div>
          <div><span id="srvTime">—</span> <span class="muted small" id="clockSkew"></span></div>

          <div class="key">Пинг</div>
          <div><span id="latency">—</span></div>
        </div>
        <div class="small muted" style="margin-top:8px">Обновление каждые 10 секунд</div>
      </article>

      <article class="card span-6" aria-labelledby="metricsTitle">
        <h2 id="metricsTitle" class="title">Метрики (сводка из /metrics)</h2>
        <table aria-describedby="metricsHelp">
          <thead><tr><th>Метрика</th><th>Значение</th></tr></thead>
          <tbody id="metricsTable">
            <tr><td class="muted" colspan="2">Загрузка…</td></tr>
          </tbody>
        </table>
        <p id="metricsHelp" class="small muted">Показываются ключевые счётчики/гауги по префиксу pic_ и grpc_/process_ (если доступны).</p>
      </article>

      <article class="card span-8" aria-labelledby="eventsTitle">
        <h2 id="eventsTitle" class="title">События</h2>
        <div class="row" style="margin-bottom:8px">
          <span class="muted small">Источник: SSE /api/v1/events (если доступно; иначе опрос)</span>
          <span id="eventsStatus" class="chip right">offline</span>
        </div>
        <pre id="events" aria-live="polite" aria-atomic="false"></pre>
      </article>

      <article class="card span-4" aria-labelledby="actionsTitle">
        <h2 id="actionsTitle" class="title">Действия</h2>
        <div class="row">
          <button id="btnRefresh" class="primary">Обновить статус</button>
          <button id="btnPurge">Очистить кеш</button>
          <button id="btnReload">Перечитать конфиг</button>
        </div>
        <p class="small muted">Действия вызывают POST на /api/v1/admin/* при наличии соответствующих эндпоинтов.</p>
      </article>
    </section>
  </main>

  <noscript><div class="wrap"><p>Для работы панели требуется JavaScript.</p></div></noscript>

  <script>
  // Минимальный «ядро» админки без внешних зависимостей.
  (function(){
    "use strict";

    // Конфигурация и хранилище
    const qs = sel => document.querySelector(sel);
    const $apiBase = qs('#apiBase');
    const $token = qs('#token');
    const $saveBase = qs('#saveBase');
    const $clearToken = qs('#clearToken');
    const $theme = qs('#themeToggle');

    const $envChip = qs('#envChip');
    const $versionChip = qs('#versionChip');

    const $healthBadge = qs('#healthBadge');
    const $healthText = qs('#healthText');
    const $version = qs('#version');
    const $uptime = qs('#uptime');
    const $srvTime = qs('#srvTime');
    const $clockSkew = qs('#clockSkew');
    const $latency = qs('#latency');

    const $metricsTable = qs('#metricsTable');

    const $events = qs('#events');
    const $eventsStatus = qs('#eventsStatus');

    const $btnRefresh = qs('#btnRefresh');
    const $btnPurge = qs('#btnPurge');
    const $btnReload = qs('#btnReload');

    const state = {
      base: localStorage.getItem('pic.web.base') || window.location.origin,
      env: 'prod',
      version: '0.0.0',
      clockSkewMs: 0,
      sse: null,
      sseEnabled: true
    };

    // Безопасность: токен хранится только в sessionStorage
    const tokenKey = 'pic.web.token';
    function getToken(){ return sessionStorage.getItem(tokenKey) || ''; }
    function setToken(t){ if(t){ sessionStorage.setItem(tokenKey, t); } }

    // Тема
    try {
      const storedTheme = localStorage.getItem('pic.web.theme');
      const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      const dark = storedTheme ? storedTheme === 'dark' : prefersDark;
      document.documentElement.style.colorScheme = dark ? 'dark' : 'light';
      $theme.checked = dark;
      $theme.addEventListener('change', () => {
        const on = $theme.checked;
        document.documentElement.style.colorScheme = on ? 'dark' : 'light';
        localStorage.setItem('pic.web.theme', on ? 'dark' : 'light');
      });
    } catch(e){}

    // Инициализация полей
    $apiBase.value = state.base;
    $token.value = getToken();

    $saveBase.addEventListener('click', () => {
      try{
        const u = new URL($apiBase.value);
        state.base = u.origin;
        localStorage.setItem('pic.web.base', state.base);
        toast('Сохранено');
        refreshAll();
      }catch(e){
        toast('Некорректный URL', true);
      }
    });
    $clearToken.addEventListener('click', () => {
      sessionStorage.removeItem(tokenKey);
      $token.value = '';
      toast('Токен очищен');
    });
    $token.addEventListener('change', () => setToken($token.value));

    // Утилиты
    function apiUrl(path){
      // Разрешаем абсолютные пути
      try {
        const u = new URL(path, state.base);
        return u.href;
      } catch(e){
        return state.base.replace(/\/+$/,'') + '/' + String(path || '').replace(/^\/+/,'');
      }
    }

    async function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

    async function fetchWithRetry(path, opts = {}, retries = 2, backoffMs = 300){
      const url = apiUrl(path);
      const headers = new Headers(opts.headers || {});
      const tok = getToken();
      if(tok && !headers.has('authorization')){
        headers.set('authorization', tok.startsWith('Bearer ') ? tok : 'Bearer ' + tok);
      }
      headers.set('accept', headers.get('accept') || 'application/json, text/plain;q=0.8, */*;q=0.5');
      const req = { ...opts, headers, credentials: 'include', cache: 'no-store' };

      let lastErr;
      for(let i=0;i<=retries;i++){
        const t0 = performance.now();
        try{
          const res = await fetch(url, req);
          const dt = performance.now() - t0;
          if(!res.ok){
            lastErr = new Error('HTTP '+res.status);
            if(res.status >= 500 && i < retries){ await sleep(backoffMs * Math.pow(2,i)); continue; }
          }
          return { res, dt };
        }catch(e){
          lastErr = e;
          if(i < retries){ await sleep(backoffMs * Math.pow(2,i)); continue; }
        }
      }
      throw lastErr;
    }

    function setHealth(status, text){
      const dot = $healthBadge.querySelector('.dot');
      dot.classList.remove('ok','warn','err');
      if(status==='ok'){ dot.classList.add('ok'); }
      else if(status==='warn'){ dot.classList.add('warn'); }
      else { dot.classList.add('err'); }
      $healthText.textContent = text || status;
    }

    function fmtMs(ms){
      if(ms < 1000) return ms.toFixed(0)+' ms';
      return (ms/1000).toFixed(2)+' s';
    }
    function fmtUptime(sec){
      const d = Math.floor(sec/86400), h = Math.floor((sec%86400)/3600), m = Math.floor((sec%3600)/60);
      return (d?d+'d ':'') + (h?h+'h ':'') + (m?m+'m':'');
    }

    // Статус/версия/пинг
    async function updateStatus(){
      try{
        // health
        const { res: r1, dt: lat } = await fetchWithRetry('/api/v1/health', {}, 1);
        $latency.textContent = fmtMs(lat);
        let health = 'unknown';
        let srvNow;
        if((r1.headers.get('content-type')||'').includes('application/json')){
          const j = await r1.json().catch(()=> ({}));
          health = j.status || j.state || (r1.ok?'ok':'error');
          srvNow = j.time || j.now || null;
          const env = j.env || j.environment || null;
          if(env){ state.env = String(env); $envChip.textContent = 'env: '+state.env; }
        }else{
          health = r1.ok ? 'ok' : 'error';
        }
        setHealth(health==='ok'?'ok':(health==='degraded'?'warn':'err'), health);

        // version
        const { res: r2 } = await fetchWithRetry('/api/v1/version', {}, 1);
        if((r2.headers.get('content-type')||'').includes('application/json')){
          const v = await r2.json().catch(()=> ({}));
          const ver = v.version || v.appVersion || v.git || '—';
          $version.textContent = ver;
          $versionChip.textContent = 'v'+ver;
          state.version = ver;
          // uptime/time
          if(typeof v.uptimeSec === 'number'){ $uptime.textContent = fmtUptime(v.uptimeSec); }
          if(v.time){ srvNow = v.time; }
        }else{
          $version.textContent = state.version;
        }

        // server time and skew
        if(srvNow){
          const serverTs = Date.parse(srvNow);
          if(!Number.isNaN(serverTs)){
            const localTs = Date.now();
            const skew = serverTs - localTs;
            state.clockSkewMs = skew;
            $srvTime.textContent = new Date(serverTs).toISOString();
            const abs = Math.abs(skew);
            $clockSkew.textContent = (abs>1000? 'Δ≈'+fmtMs(abs) : '');
          }
        }
      }catch(e){
        setHealth('err', 'unreachable');
        $latency.textContent = '—';
      }
    }

    // Метрики: парсим text/plain из Prometheus endpoint
    const METRIC_PATTERNS = [
      /^pic_norm_events_total\{route="(?<route>[^"]+)",result="(?<res>[^"]+)"\}\s+(?<val>[\d\.eE\+\-]+)/m,
      /^grpc_server_requests_total\{[^}]*code="(?<code>[^"]+)"[^}]*\}\s+(?<val>[\d\.eE\+\-]+)/m,
      /^process_open_fds\}\s+(?<val>[\d\.eE\+\-]+)/m,
      /^process_resident_memory_bytes\}\s+(?<val>[\d\.eE\+\-]+)/m,
      /^python_gc_objects_collected_total\{generation="(?<gen>\d)"\}\s+(?<val>[\d\.eE\+\-]+)/m
    ];
    function parseMetricBlock(text, re){
      const m = text.match(re);
      if(!m) return null;
      const groups = m.groups || {};
      return { ...groups };
    }
    async function updateMetrics(){
      try{
        const { res } = await fetchWithRetry('/metrics', { headers: { 'accept':'text/plain' } }, 0);
        const body = await res.text();
        const rows = [];
        // pic_norm_events_total (ok)
        const ok = [...body.matchAll(/pic_norm_events_total\{route="([^"]+)",result="ok"\}\s+([\d\.eE\+\-]+)/g)]
          .slice(0,5).map(m => ({name:'norm ok ['+m[1]+']', val:m[2]}));
        rows.push(...ok);
        // grpc codes summary
        const codes = {};
        for(const m of body.matchAll(/grpc_server_requests_total\{[^}]*code="([^"]+)"[^}]*\}\s+([\d\.eE\+\-]+)/g)){
          codes[m[1]] = (codes[m[1]]||0) + Number(m[2]);
        }
        if(Object.keys(codes).length){
          rows.push({name:'grpc requests (by code)', val: JSON.stringify(codes)});
        }
        // fds and memory
        const fds = body.match(/^process_open_fds\}\s+([\d\.eE\+\-]+)/m);
        if(fds) rows.push({name:'open_fds', val:fds[1]});
        const rss = body.match(/^process_resident_memory_bytes\}\s+([\d\.eE\+\-]+)/m);
        if(rss) rows.push({name:'rss_bytes', val:rss[1]});

        renderTable(rows);
      }catch(e){
        renderTable([{name:'метрики недоступны', val:'—'}]);
      }
    }
    function renderTable(items){
      $metricsTable.innerHTML = '';
      if(!items || !items.length){
        $metricsTable.innerHTML = '<tr><td class="muted" colspan="2">Нет данных</td></tr>';
        return;
      }
      for(const it of items){
        const tr = document.createElement('tr');
        const td1 = document.createElement('td'); td1.textContent = it.name;
        const td2 = document.createElement('td'); td2.textContent = String(it.val);
        tr.appendChild(td1); tr.appendChild(td2);
        $metricsTable.appendChild(tr);
      }
    }

    // События: SSE (если без токена) или fallback polling
    function startEvents(){
      stopEvents();
      // Если есть токен — большинство SSE серверов не принимают заголовки, пропускаем
      if(getToken()){ state.sseEnabled = false; $eventsStatus.textContent='polling'; startPolling(); return; }

      try{
        const url = apiUrl('/api/v1/events');
        const es = new EventSource(url, { withCredentials: true });
        state.sse = es;
        $eventsStatus.textContent = 'sse';
        es.onmessage = (ev) => {
          const line = (ev.data || '').slice(0, 2000);
          appendEvent(line);
        };
        es.onerror = () => {
          $eventsStatus.textContent = 'offline';
          stopEvents();
          startPolling();
        };
      }catch(e){
        $eventsStatus.textContent = 'offline';
        startPolling();
      }
    }
    function stopEvents(){
      if(state.sse){ try{ state.sse.close(); }catch(e){} state.sse = null; }
    }
    let pollTimer = null;
    function startPolling(){
      clearInterval(pollTimer);
      pollTimer = setInterval(async () => {
        try{
          const { res } = await fetchWithRetry('/api/v1/logs/tail?limit=50', {}, 0);
          if(res.ok){
            const j = await res.json().catch(()=>[]);
            if(Array.isArray(j)){
              $events.textContent='';
              j.forEach(x => appendEvent(typeof x==='string'? x: JSON.stringify(x)));
            }
          }
        }catch(e){}
      }, 5000);
    }
    function appendEvent(line){
      const ts = new Date(Date.now() + state.clockSkewMs).toISOString();
      const txt = `[${ts}] ${line}\n`;
      $events.append(document.createTextNode(txt));
      // автоскролл вниз
      $events.scrollTop = $events.scrollHeight;
    }

    // Действия
    $btnRefresh.addEventListener('click', refreshAll);
    $btnPurge.addEventListener('click', async () => {
      try{
        const { res } = await fetchWithRetry('/api/v1/admin/cache/purge', { method:'POST' }, 0);
        toast(res.ok ? 'Кеш очищен' : 'Ошибка очистки');
      }catch(e){ toast('Недоступно', true); }
    });
    $btnReload.addEventListener('click', async () => {
      try{
        const { res } = await fetchWithRetry('/api/v1/admin/reload', { method:'POST' }, 0);
        toast(res.ok ? 'Конфиг перечитан' : 'Ошибка операции');
      }catch(e){ toast('Недоступно', true); }
    });

    // Service Worker: inline Blob регистрация (кеширует index.html и ответы health/metrics)
    async function registerSW(){
      if(!('serviceWorker' in navigator)) return;
      const swSrc = `
        const CACHE='pic-admin-v1';
        const CORE=['./'];
        self.addEventListener('install',e=>{ e.waitUntil(caches.open(CACHE).then(c=>c.addAll(CORE)).then(()=>self.skipWaiting()))});
        self.addEventListener('activate',e=>{ e.waitUntil(self.clients.claim())});
        self.addEventListener('fetch',e=>{
          const u=new URL(e.request.url);
          if(e.request.method!=='GET'){ return; }
          if(u.pathname.endsWith('/api/v1/health')||u.pathname.endsWith('/metrics')){
            e.respondWith(fetch(e.request).then(r=>{ const x=r.clone(); caches.open(CACHE).then(c=>c.put(e.request,x)); return r; })
              .catch(()=>caches.match(e.request)));
            return;
          }
          if(u.origin===location.origin){
            e.respondWith(caches.match(e.request).then(m=> m || fetch(e.request)));
          }
        });
      `;
      const blob = new Blob([swSrc], {type:'text/javascript'});
      const url = URL.createObjectURL(blob);
      try{
        await navigator.serviceWorker.register(url, { scope:'./' });
      }catch(e){}
    }

    // Тосты
    let toastTimer=null;
    function toast(text, error){
      let t = document.getElementById('toast');
      if(!t){
        t = document.createElement('div');
        t.id='toast';
        t.setAttribute('role','status');
        t.setAttribute('aria-live','polite');
        t.style.position='fixed'; t.style.bottom='16px'; t.style.left='50%'; t.style.transform='translateX(-50%)';
        t.style.padding='8px 12px'; t.style.border='1px solid var(--border)'; t.style.borderRadius='10px';
        t.style.background='var(--panel)'; t.style.color='var(--text)'; t.style.boxShadow='0 10px 20px rgba(0,0,0,.2)';
        document.body.appendChild(t);
      }
      t.textContent = text;
      t.style.borderColor = error ? 'var(--err)' : 'var(--border)';
      clearTimeout(toastTimer);
      toastTimer = setTimeout(()=> t.remove(), 2500);
    }

    // Основной цикл обновления
    async function refreshAll(){
      await updateStatus();
      await updateMetrics();
      startEvents();
    }

    // Автообновление каждые 10с
    setInterval(updateStatus, 10000);
    setInterval(updateMetrics, 15000);

    // Старт
    (async function start(){
      // Обновим «env» с учётом ENV переменной страницы (если отдана через серверный шаблон)
      const htmlEnv = document.documentElement.getAttribute('data-env');
      if(htmlEnv){ state.env = htmlEnv; $envChip.textContent = 'env: '+state.env; }
      await registerSW();
      await refreshAll();
    })();

  })();
  </script>
</body>
</html>
