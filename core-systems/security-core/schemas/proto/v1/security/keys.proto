// security-core/schemas/proto/v1/security/keys.proto
syntax = "proto3";

package aethernova.security.v1;

option go_package           = "github.com/aethernova/security-core/gen/proto/aethernova/security/v1;securityv1";
option java_multiple_files  = true;
option java_package         = "org.aethernova.security.v1";
option java_outer_classname = "KeysProto";
option csharp_namespace     = "Aethernova.Security.V1";
option objc_class_prefix    = "AVS";
option php_namespace        = "Aethernova\\Security\\V1";
option ruby_package         = "Aethernova::Security::V1";
option cc_enable_arenas     = true;
option optimize_for         = SPEED;

import "google/protobuf/any.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/field_mask.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";

// ========================= Core Enums =========================

enum KeyAlgorithm {
  KEY_ALGORITHM_UNSPECIFIED = 0;
  // Asymmetric classical
  RSA_2048   = 1;
  RSA_3072   = 2;
  RSA_4096   = 3;
  ECDSA_P256 = 10;
  ECDSA_P384 = 11;
  SECP256K1  = 12;
  ED25519    = 13;
  X25519     = 14;

  // Symmetric
  AES_128_GCM           = 30;
  AES_256_GCM           = 31;
  CHACHA20_POLY1305     = 32;

  // NIST PQC (standardized names generalized)
  ML_KEM_768            = 50; // Kyber-768
  ML_KEM_1024           = 51; // Kyber-1024
  ML_DSA_65             = 52; // Dilithium-2/3 family mapped
  ML_DSA_87             = 53; // Dilithium-3/5 family mapped
}

enum SignatureAlgorithm {
  SIGALG_UNSPECIFIED          = 0;
  RSASSA_PSS_SHA256           = 1;
  RSASSA_PSS_SHA384           = 2;
  RSASSA_PKCS1_V15_SHA256     = 3;
  ECDSA_P256_SHA256           = 10;
  ECDSA_P384_SHA384           = 11;
  ED25519_SIGN                = 20;
  SECP256K1_ECDSA_SHA256      = 21;
  ML_DSA_65_SIGN              = 40;
  ML_DSA_87_SIGN              = 41;
}

enum EncryptionAlgorithm {
  ENC_UNSPECIFIED                 = 0;
  RSA_OAEP_SHA256                 = 1;
  ECIES_X25519_XCHACHA20_POLY1305 = 2;
  AES_GCM_128_ENC                 = 10;
  AES_GCM_256_ENC                 = 11;
  CHACHA20_POLY1305_ENC           = 12;
  ML_KEM_768_HKDF_SHA256          = 30;
  ML_KEM_1024_HKDF_SHA384         = 31;
}

enum WrappingAlgorithm {
  WRAP_ALG_UNSPECIFIED   = 0;
  AES_KW_256_RFC3394     = 1;
  AES_KWP_256_RFC5649    = 2;
  RSA_OAEP_SHA256_WRAP   = 3;
  X25519_XCHACHA20_WRAP  = 4;
  ML_KEM_768_WRAP        = 10;
}

enum KeyEncoding {
  KEY_ENCODING_UNSPECIFIED = 0;
  RAW                      = 1;  // raw public (e.g., 32 bytes X25519/Ed25519)
  DER                      = 2;  // DER/SPKI/PKCS#8 as applicable
  PEM                      = 3;  // PEM with appropriate headers
  JWK                      = 4;  // JSON Web Key (normalized fields)
}

enum KeyPurpose {
  PURPOSE_UNSPECIFIED = 0;
  SIGN                = 1;
  VERIFY              = 2;
  ENCRYPT             = 3;
  DECRYPT             = 4;
  WRAP_KEY            = 5;
  UNWRAP_KEY          = 6;
  KEY_EXCHANGE        = 7;
  ATTESTATION         = 8;
  DERIVE              = 9;
}

enum KeyState {
  KEY_STATE_UNSPECIFIED = 0;
  PENDING_GENERATION    = 1;
  PENDING_IMPORT        = 2;
  ACTIVE                = 3;
  DISABLED              = 4;
  COMPROMISED           = 5;
  PENDING_DELETION      = 6;
  DESTROYED             = 7;
}

enum ProtectionLevel {
  PROTECTION_LEVEL_UNSPECIFIED = 0;
  SOFTWARE                     = 1; // soft-keystore with hardening
  HSM                          = 2; // FIPS 140-3 validated where applicable
  EXTERNAL_KMS                 = 3; // cloud/on-prem provider
  TEE                          = 4; // SGX/SEV-SNP/CCA
  SHAMIR_SPLIT                 = 5; // M-of-N secret sharing (no single holder)
}

enum AttestationFormat {
  ATTESTATION_FORMAT_UNSPECIFIED = 0;
  TPM_TPM2_QUOTE                 = 1;
  INTEL_SGX_ECDSA                = 2;
  AMD_SEV_SNP                    = 3;
  ARM_CCA_REALM                  = 4;
  GOOGLE_TITAN                   = 5;
}

// ========================= Primitive Types =========================

message Wrapping {
  WrappingAlgorithm algorithm = 1;
  string wrapping_key_uri     = 2; // kms://, hsm://, keyvault:// etc.
  bytes iv                    = 3; // when applicable
  bytes aad                   = 4; // associated data, if any
}

message KeyMaterial {
  oneof location {
    // Strongly discouraged to transport private_der over the wire; keep for
    // regulated migrations with strict transport controls.
    bytes private_der      = 1;  // PKCS#8 DER (RESTRICTED: DO NOT LOG)
    string external_kms_uri= 2;  // kms://provider/...
    bytes wrapped          = 3;  // wrapped private key blob
    string tee_object_id   = 4;  // opaque handle in TEE
    string hsm_key_id      = 5;  // HSM opaque identifier
  }
  KeyEncoding encoding     = 10; // encoding of private_der (if present)
  Wrapping wrapping        = 11; // wrapping metadata (if wrapped)
  bool exportable          = 12; // whether private material is exportable
}

message KeyAttestation {
  AttestationFormat format = 1;
  bytes quote              = 2; // raw attestation evidence/quote
  map<string, bytes> evidence = 3; // aux data (certs, endorsements)
  google.protobuf.Timestamp verified_at = 4;
  bool verified            = 5; // result after policy verification
  string verifier          = 6; // verifier impl id/version
}

message ComplianceTags {
  repeated string standards = 1; // e.g., "FIPS140-3", "PCI-DSS", "ISO27001"
  bool fips_approved        = 2;
}

message KeyAccessPolicy {
  repeated string allowed_service_accounts = 1; // principal URIs
  repeated string allowed_principals       = 2; // users/groups/roles
  repeated string allowed_networks         = 3; // CIDR list
  bool require_attestation                 = 4; // enforce TEE/HSM attestation
  map<string, string> abac_conditions      = 5; // ABAC claims (env, region)
}

message KeyRotationPolicy {
  bool automatic                         = 1;
  google.protobuf.Duration rotation_period = 2;  // e.g., 90d
  int32 max_active_versions              = 3;    // cap on coexisting ACTIVE
  int32 min_active_days                  = 4;    // safety window before rotate
  google.protobuf.Timestamp next_rotation_time = 5;
}

// ========================= Public Key & CSR =========================

message PublicKey {
  string name            = 1; // tenants/{tenant}/keys/{key}/versions/{version}
  KeyAlgorithm algorithm = 2;
  KeyEncoding encoding   = 3;
  bytes key_bytes        = 4; // DER/SPKI or raw depending on encoding
  string pem             = 5; // optional PEM
  string fingerprint     = 6; // base64url(SHA-256)
}

message CertificateSigningRequest {
  string name     = 1; // tenants/{tenant}/keys/{key}/versions/{version}
  bytes pkcs10_der= 2;
  string pem      = 3; // optional
}

// ========================= JWK / JWKS =========================

message Jwk {
  string kid                 = 1;
  string kty                 = 2;
  string use                 = 3; // "sig", "enc"
  string alg                 = 4;
  repeated string key_ops    = 5;
  // RSA
  string n                   = 10;
  string e                   = 11;
  // EC / OKP
  string crv                 = 20;
  string x                   = 21;
  string y                   = 22;
  // Symmetric (oct)
  string k                   = 30;
  // X.509
  repeated string x5c        = 40;
  string x5t                 = 41;
  string x5t_s256            = 42;
}

message Jwks {
  repeated Jwk keys = 1;
}

// ========================= Resource Model =========================

message KeyVersion {
  string name                        = 1;  // tenants/{tenant}/keys/{key}/versions/{version}
  int64 version_id                   = 2;
  KeyState state                     = 3;
  KeyAlgorithm algorithm             = 4;
  KeyMaterial material               = 5;  // private material location/handle
  PublicKey public_key               = 6;
  KeyEncoding public_encoding        = 7;
  google.protobuf.Timestamp create_time   = 8;
  google.protobuf.Timestamp expire_time   = 9;
  google.protobuf.Timestamp destroy_time  = 10;
  KeyAttestation attestation         = 11;
}

message CryptoKey {
  string name                         = 1;  // tenants/{tenant}/keys/{key}
  string tenant                       = 2;  // tenants/{tenant}
  string description                  = 3;
  KeyAlgorithm algorithm              = 4;
  ProtectionLevel protection_level    = 5;
  KeyState state                      = 6;
  KeyPurpose primary_purpose          = 7;
  repeated KeyPurpose purposes        = 8;  // allowed usages
  KeyRotationPolicy rotation_policy   = 9;
  KeyAccessPolicy access_policy       = 10;
  map<string,string> labels           = 11;
  ComplianceTags compliance           = 12;
  string kms_uri                      = 13; // external provider binding
  google.protobuf.Timestamp create_time  = 14;
  google.protobuf.Timestamp update_time  = 15;
  int32 destroy_safety_period_days    = 16; // delay before irreversible destroy
  KeyVersion primary_version          = 17;
  repeated KeyVersion versions        = 18; // optionally trimmed server-side
  KeyAttestation attestation          = 19; // device-/env-level attestation
}

// ========================= Requests / Responses =========================

message CreateKeyRequest {
  string parent               = 1; // tenants/{tenant}
  string key_id               = 2; // {key}
  CryptoKey key               = 3; // algorithm, protection_level, purposes...
  bool generate_primary       = 4; // if true, server creates first version
}

message ImportKeyRequest {
  string parent               = 1; // tenants/{tenant}
  string key_id               = 2;
  CryptoKey key               = 3; // metadata/policy
  KeyVersion version          = 4; // includes material (wrapped/kms/tee/hsm)
}

message GetKeyRequest {
  string name                 = 1; // tenants/{tenant}/keys/{key}
  bool include_versions       = 2; // if true, include versions[] snapshot
}

message ListKeysRequest {
  string parent               = 1; // tenants/{tenant}
  int32 page_size             = 2;
  string page_token           = 3;
  string filter               = 4; // labels, algorithm, state, protection_level
  string order_by             = 5; // create_time desc, update_time desc, etc.
}

message ListKeysResponse {
  repeated CryptoKey keys     = 1;
  string next_page_token      = 2;
}

message UpdateKeyRequest {
  CryptoKey key               = 1;
  google.protobuf.FieldMask update_mask = 2; // updatable: description, labels, policies
}

message RotateKeyRequest {
  string name                 = 1; // tenants/{tenant}/keys/{key}
  // Optional explicit controls, else server follows rotation_policy.
  google.protobuf.Timestamp effective_time = 2;
}

message ScheduleKeyDestructionRequest {
  string name                 = 1; // tenants/{tenant}/keys/{key}/versions/{version}
  google.protobuf.Timestamp destroy_time = 2; // must respect safety period
}

message RestoreKeyVersionRequest {
  string name                 = 1; // tenants/{tenant}/keys/{key}/versions/{version}
}

message GetPublicKeyRequest {
  string name                 = 1; // tenants/{tenant}/keys/{key}/versions/{version}
  KeyEncoding preferred_encoding = 2;
}

message GenerateCsrRequest {
  string name                 = 1; // tenants/{tenant}/keys/{key}/versions/{version}
  string subject_dn           = 2; // e.g., "CN=service,O=Aethernova,L=..."
  repeated string subject_alt_names = 3; // SANs: DNS, URI, IP
  map<string,string> extensions     = 4; // OIDs->values (string-encoded)
}

message SignRequest {
  string name                       = 1; // tenants/{tenant}/keys/{key}/versions/{version}
  SignatureAlgorithm signature_algorithm = 2;
  oneof input {
    bytes digest                    = 3;
    bytes plaintext                 = 4;
  }
  bytes salt                        = 5; // for PSS, or context binding
  map<string,string> context        = 6; // audit/ABAC context
}

message SignResponse {
  bytes signature                   = 1;
}

message VerifyRequest {
  PublicKey public_key              = 1; // or reference name if using server-stored
  SignatureAlgorithm signature_algorithm = 2;
  oneof input {
    bytes digest                    = 3;
    bytes plaintext                 = 4;
  }
  bytes signature                   = 5;
}

message VerifyResponse {
  bool valid                        = 1;
  string error_message              = 2;
}

message EncryptRequest {
  string name                       = 1; // key or version
  EncryptionAlgorithm encryption_algorithm = 2;
  bytes plaintext                   = 3;
  bytes aad                         = 4;
}

message EncryptResponse {
  bytes ciphertext                  = 1;
  bytes iv                          = 2;
  bytes tag                         = 3; // AEAD tag, if applicable
}

message DecryptRequest {
  string name                       = 1;
  EncryptionAlgorithm encryption_algorithm = 2;
  bytes ciphertext                  = 3;
  bytes aad                         = 4;
  bytes iv                          = 5;
  bytes tag                         = 6;
}

message DecryptResponse {
  bytes plaintext                   = 1;
}

message WrapKeyRequest {
  string name                       = 1; // wrapping key reference
  WrappingAlgorithm algorithm       = 2;
  bytes target_key_material         = 3; // symmetric or private key (restricted)
  bytes aad                         = 4;
}

message WrapKeyResponse {
  bytes wrapped_key                 = 1;
}

message UnwrapKeyRequest {
  string name                       = 1; // unwrapping key reference
  WrappingAlgorithm algorithm       = 2;
  bytes wrapped_key                 = 3;
  bytes aad                         = 4;
}

message UnwrapKeyResponse {
  bytes key_material                = 1; // restricted handling
}

message AttestKeyRequest {
  string name                       = 1; // key or version
  google.protobuf.Struct claims     = 2; // expected claims/policies
}

message AttestKeyResponse {
  KeyAttestation attestation        = 1;
}

message GetJwksRequest {
  string parent                     = 1; // tenants/{tenant}
  string filter                     = 2; // by label, purpose, algorithm
  bool include_inactive             = 3; // include DISABLED for key rollover windows
}

message GetJwksResponse {
  Jwks jwks                         = 1;
}

// ========================= Service =========================

service KeyManagement {
  rpc CreateKey                 (CreateKeyRequest)                 returns (CryptoKey);
  rpc ImportKey                 (ImportKeyRequest)                 returns (CryptoKey);
  rpc GetKey                    (GetKeyRequest)                    returns (CryptoKey);
  rpc ListKeys                  (ListKeysRequest)                  returns (ListKeysResponse);
  rpc UpdateKey                 (UpdateKeyRequest)                 returns (CryptoKey);

  rpc RotateKey                 (RotateKeyRequest)                 returns (CryptoKey);
  rpc ScheduleKeyDestruction    (ScheduleKeyDestructionRequest)    returns (KeyVersion);
  rpc RestoreKeyVersion         (RestoreKeyVersionRequest)         returns (KeyVersion);

  rpc GetPublicKey              (GetPublicKeyRequest)              returns (PublicKey);
  rpc GenerateCsr               (GenerateCsrRequest)               returns (CertificateSigningRequest);

  rpc Sign                      (SignRequest)                      returns (SignResponse);
  rpc Verify                    (VerifyRequest)                    returns (VerifyResponse);

  rpc Encrypt                   (EncryptRequest)                   returns (EncryptResponse);
  rpc Decrypt                   (DecryptRequest)                   returns (DecryptResponse);

  rpc WrapKey                   (WrapKeyRequest)                   returns (WrapKeyResponse);
  rpc UnwrapKey                 (UnwrapKeyRequest)                 returns (UnwrapKeyResponse);

  rpc AttestKey                 (AttestKeyRequest)                 returns (AttestKeyResponse);

  rpc GetJwks                   (GetJwksRequest)                   returns (GetJwksResponse);
}
