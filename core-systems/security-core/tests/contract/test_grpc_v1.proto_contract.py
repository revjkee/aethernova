# security-core/tests/contract/test_grpc_v1.proto_contract.py
# -*- coding: utf-8 -*-
"""
Контрактные проверки для gRPC/Protobuf схем v1.

Поведение:
- Пытается скомпилировать все .proto из schemas/proto/v1/** в tmp‑каталог.
- Если grpc_tools/protoc недоступен — помечает suite как skipped.
- Инспектирует дескрипторы (FileDescriptor/ServiceDescriptor/Descriptor/EnumDescriptor).
- Проверяет инварианты стабильного публичного API.

Требуются пакеты: protobuf, pytest, (опционально) grpcio-tools.
"""
from __future__ import annotations

import importlib
import io
import os
import re
import sys
import types
from pathlib import Path
from typing import Iterable, List, Tuple

import pytest

try:
    from grpc_tools import protoc  # type: ignore
    _HAVE_GRPC_TOOLS = True
except Exception:  # pragma: no cover
    _HAVE_GRPC_TOOLS = False

try:
    from google.protobuf import descriptor as _desc  # type: ignore
    from google.protobuf import json_format as _json  # type: ignore
    _HAVE_PROTOBUF = True
except Exception:  # pragma: no cover
    _HAVE_PROTOBUF = False


# ------------------------------- Фикстуры -------------------------------

@pytest.fixture(scope="module")
def repo_root() -> Path:
    # tests/contract/... -> корень репозитория
    here = Path(__file__).resolve()
    return here.parents[3] if (len(here.parents) >= 4) else here.parents[2]


@pytest.fixture(scope="module")
def proto_root(repo_root: Path) -> Path:
    p = repo_root / "schemas" / "proto" / "v1"
    if not p.exists():
        pytest.skip("schemas/proto/v1 not found")
    return p


@pytest.fixture(scope="module")
def compiled_pkg(tmp_path_factory, proto_root: Path, repo_root: Path) -> Tuple[Path, List[Path]]:
    """
    Компилирует все .proto из v1 в временной каталог.
    Возвращает (py_out_dir, список python-модулей .py для импортирования).
    """
    if not _HAVE_PROTOBUF:
        pytest.skip("protobuf not available")
    if not _HAVE_GRPC_TOOLS:
        pytest.skip("grpc_tools.protoc not available")

    out = tmp_path_factory.mktemp("pb_out")
    py_out = out
    grpc_out = out

    # Собираем список .proto
    protos = [p for p in proto_root.rglob("*.proto")]
    assert protos, "No .proto files found under schemas/proto/v1"

    # protoc: include путь — корень schemas/proto и сам v1
    include1 = str((repo_root / "schemas" / "proto").resolve())
    include2 = str(proto_root.resolve())

    args = [
        "protoc",
        f"-I{include1}",
        f"-I{include2}",
        f"--python_out={py_out}",
        f"--grpc_python_out={grpc_out}",
    ] + [str(p) for p in protos]

    rc = protoc.main(args)
    assert rc == 0, f"protoc returned non-zero: {rc}"

    # Добавим tmp каталог в sys.path для импорта
    sys.path.insert(0, str(py_out))
    generated = list(py_out.rglob("*_pb2.py"))
    assert generated, "No *_pb2.py generated by protoc"
    return py_out, generated


@pytest.fixture(scope="module")
def loaded_modules(compiled_pkg: Tuple[Path, List[Path]]):
    py_out, files = compiled_pkg
    mods = []
    for f in files:
        # Определяем модульное имя из относительного пути
        rel = f.relative_to(py_out).with_suffix("")
        mod_name = ".".join(rel.parts)
        mods.append(importlib.import_module(mod_name))
    return mods


# ------------------------------- Хелперы -------------------------------

_SNAKE = re.compile(r"^[a-z][a-z0-9_]*$")

def _camelize(s: str) -> str:
    """lowerCamelCase для сопоставления json_name."""
    parts = s.split("_")
    return parts[0] + "".join(p.capitalize() or "_" for p in parts[1:])


def _iter_descriptors(mod) -> Iterable[_desc.FileDescriptor]:
    if hasattr(mod, "DESCRIPTOR"):
        yield mod.DESCRIPTOR
    for name in dir(mod):
        v = getattr(mod, name)
        if isinstance(v, types.ModuleType) and getattr(v, "DESCRIPTOR", None) is not None:
            yield v.DESCRIPTOR


# ------------------------------- Тесты: файл/пакет/версии -------------------------------

def test_proto3_and_package_version(proto_root: Path):
    # Проверяем синтаксис и пакет на уровне исходников .proto
    texts = {p: p.read_text(encoding="utf-8") for p in proto_root.rglob("*.proto")}
    assert texts, "no .proto files to inspect"

    for path, txt in texts.items():
        assert 'syntax = "proto3";' in txt, f"{path} must declare proto3 syntax"
        # Пакет должен содержать версионирование v1
        m = re.search(r"^\s*package\s+([a-zA-Z0-9_.]+)\s*;", txt, flags=re.M)
        assert m, f"{path}: package declaration required"
        pkg = m.group(1)
        assert ".v1" in pkg or pkg.endswith("v1"), f"{path}: package should include version segment v1 (got {pkg})"


# ------------------------------- Тесты: дескрипторы и RPC -------------------------------

def test_services_unary_no_streaming(loaded_modules):
    found_any = False
    for mod in loaded_modules:
        for fd in _iter_descriptors(mod):
            for svc in fd.services_by_name.values():
                found_any = True
                for mth in svc.methods:
                    # Контракт: unary RPC в публичном API
                    assert not mth.client_streaming, f"{svc.full_name}.{mth.name} must be unary (no client streaming)"
                    assert not mth.server_streaming, f"{svc.full_name}.{mth.name} must be unary (no server streaming)"
                    # Request/Response должны существовать
                    assert mth.input_type is not None and mth.output_type is not None
    assert found_any, "no services discovered in compiled descriptors"


def test_message_naming_conventions_and_fields(loaded_modules):
    for mod in loaded_modules:
        for fd in _iter_descriptors(mod):
            # Сообщения
            for msg in fd.message_types_by_name.values():
                # Правило имен: snake_case для полей
                for field in msg.fields:
                    assert _SNAKE.match(field.name), f"{msg.full_name}.{field.name} must be snake_case"
                    # json_name ожидается lowerCamelCase от имени поля
                    assert field.json_name == _camelize(field.name), f"{msg.full_name}.{field.name} json_name mismatch"
                    # Запрещены required (в proto3 не должно быть)
                    assert field.label != field.LABEL_REQUIRED, f"{msg.full_name}.{field.name} must not be required"
                    # Номера полей не должны попадать в зарезервированный диапазон 19000..19999
                    assert not (19000 <= field.number <= 19999), f"{msg.full_name}.{field.name} uses reserved field number {field.number}"

            # Контракт “Request/Response” парности
            msg_names = set(fd.message_types_by_name.keys())
            for name in list(msg_names):
                if name.endswith("Request"):
                    base = name[:-7]
                    resp = base + "Response"
                    assert resp in msg_names, f"{fd.name}: message {name} must have matching {resp}"


def test_enums_zero_value_first(loaded_modules):
    for mod in loaded_modules:
        for fd in _iter_descriptors(mod):
            for enum in fd.enum_types_by_name.values():
                assert enum.values, f"{enum.full_name} must define at least one value"
                first = enum.values[0]
                assert first.number == 0, f"{enum.full_name} must declare zero value first (got {first.number})"


def test_json_roundtrip_messages_if_possible(loaded_modules):
    # Сериализация JSON <-> Message для всех сообщений без циклических ссылок.
    # Это smoke‑check корректности имен/типов.
    for mod in loaded_modules:
        for fd in _iter_descriptors(mod):
            for msg in fd.message_types_by_name.values():
                # Создаём пустой экземпляр и проверяем JSON round‑trip
                cls = getattr(importlib.import_module(fd.python_package or mod.__name__), msg.name, None)
                # В python‑gen классы сообщений обычно в модуле *_pb2, но не всегда доступны по имени.
                # Используем рефлексию через Descriptor:
                from google.protobuf import message_factory  # type: ignore
                mf = message_factory.MessageFactory()
                mtype = mf.GetPrototype(msg)
                inst = mtype()  # пустой
                js = _json.MessageToJson(inst)
                inst2 = mtype()
                _json.Parse(js, inst2)
                # Эквивалентность по сериализованным байтам
                assert inst.SerializeToString(deterministic=True) == inst2.SerializeToString(deterministic=True)


# ------------------------------- Тест: специальный контракт для Keys‑сервиса -------------------------------

@pytest.mark.parametrize("expected_method", ["Sign", "Verify", "GetPublicKey", "Encrypt", "Decrypt", "WrapKey", "UnwrapKey"])
def test_keys_service_expected_methods_if_present(loaded_modules, expected_method: str):
    """
    Если в пакетах есть сервис Keys/KeyManagement — проверяем наличие ожидаемых RPC.
    Если сервиса нет — пропускаем специфичный тест.
    Если метод не найден — помечаем xfail (сигнал отклонения от рекомендованного контракта).
    """
    services = []
    for mod in loaded_modules:
        for fd in _iter_descriptors(mod):
            for svc in fd.services_by_name.values():
                if any(k in svc.name.lower() for k in ("keys", "key", "kms", "keymanagement")):
                    services.append(svc)
    if not services:
        pytest.skip("No Keys/KeyManagement like service found")

    # Ищем метод среди обнаруженных сервисов
    for svc in services:
        if expected_method in {m.name for m in svc.methods}:
            return
    pytest.xfail(f"Expected method '{expected_method}' not found in Keys service")


# ------------------------------- Тест: стабильность импортируемых пакетов -------------------------------

def test_modules_have_descriptors_and_package_v1(loaded_modules):
    ok = False
    for mod in loaded_modules:
        desc = getattr(mod, "DESCRIPTOR", None)
        assert desc is not None, f"module {mod.__name__} must have DESCRIPTOR"
        # Проверка, что в пакете присутствует маркер версии v1
        if isinstance(desc, _desc.FileDescriptor):
            if ".v1" in desc.package or desc.package.endswith("v1"):
                ok = True
    assert ok, "no FileDescriptor with package containing v1 detected"
