# security-core/security/authz/policy_adapter.py
# Промышленный адаптер политик: нормализация, компиляция условий, индексы, потокобезопасный кэш.
# Зависимости: стандартная библиотека. (Опционально может работать с Pydantic/Proto-объектами как с dict-подобными.)
from __future__ import annotations

import ast
import base64
import hashlib
import json
import re
import threading
import time
from dataclasses import dataclass, field
from functools import lru_cache
from typing import Any, Dict, Iterable, List, Mapping, Optional, Sequence, Tuple

# =========================
# Исключения и утилиты
# =========================

class PolicyAdapterError(Exception):
    pass

def _canonical_json_bytes(obj: Any) -> bytes:
    return json.dumps(obj, sort_keys=True, separators=(",", ":"), ensure_ascii=False).encode("utf-8")

def compute_etag(obj: Any) -> str:
    h = hashlib.sha256()
    h.update(_canonical_json_bytes(obj))
    return h.hexdigest()

def _as_dict(obj: Any) -> Dict[str, Any]:
    """
    Унифицирует вход (Pydantic/Proto/dict) в dict.
    - Pydantic: .dict() / .model_dump()
    - Proto: getattr(obj, 'ListFields')? иначе через json fallback если есть .__getstate__/__dict__
    """
    if obj is None:
        return {}
    if isinstance(obj, dict):
        return obj
    # Pydantic v1/v2
    for meth in ("model_dump", "dict", "json"):
        if hasattr(obj, meth):
            try:
                if meth == "json":
                    return json.loads(getattr(obj, meth)())
                return getattr(obj, meth)()
            except Exception:
                pass
    # Proto (generated by protoc) — попробуем через json форматтеры пользователя (если есть .to_json)
    if hasattr(obj, "to_json"):
        try:
            return json.loads(obj.to_json())
        except Exception:
            pass
    # Fallback: возьмём публичные поля
    if hasattr(obj, "__dict__"):
        raw = {k: v for k, v in obj.__dict__.items() if not k.startswith("_")}
        # рекурсивная нормализация вложенных объектов
        for k, v in list(raw.items()):
            if hasattr(v, "__dict__") or isinstance(v, (list, tuple)):
                raw[k] = _deep_to_dict(v)
        return raw
    raise PolicyAdapterError(f"Unsupported policy object type: {type(obj)}")

def _deep_to_dict(v: Any) -> Any:
    if isinstance(v, dict):
        return {k: _deep_to_dict(x) for k, x in v.items()}
    if isinstance(v, list):
        return [_deep_to_dict(x) for x in v]
    if isinstance(v, tuple):
        return tuple(_deep_to_dict(x) for x in v)
    if hasattr(v, "__dict__"):
        return _as_dict(v)
    return v

def _to_str_effect(x: Any) -> str:
    if isinstance(x, str):
        x = x.upper()
        if x in ("ALLOW", "DENY"):
            return x
    if isinstance(x, int):
        return "ALLOW" if x == 1 else "DENY" if x == 2 else "DENY"
    # default fallback: безопаснее DENY
    return "DENY"

# =========================
# Транслятор CEL → безопасный Python-DSL
# =========================

_CEL_BOOL_REPLACERS = (
    (r"\btrue\b", "True"),
    (r"\bfalse\b", "False"),
    (r"\bnull\b", "None"),
)
# Простая замена операторов CEL
_CEL_OP_REPLACERS = (
    (r"&&", " and "),
    (r"\|\|", " or "),
    (r"!", " not "),
)

# Разрешённые AST-узлы в safe-eval
_ALLOWED_NODES = (
    ast.Expression, ast.BoolOp, ast.BinOp, ast.UnaryOp, ast.IfExp,
    ast.Compare, ast.Name, ast.Load, ast.Constant, ast.Subscript, ast.Attribute,
    ast.And, ast.Or, ast.Not, ast.Eq, ast.NotEq, ast.Gt, ast.GtE, ast.Lt, ast.LtE,
    ast.In, ast.NotIn, ast.Is, ast.IsNot, ast.Index, ast.Dict, ast.Tuple, ast.List,
    ast.Add, ast.Sub, ast.Mult, ast.Div, ast.Mod, ast.Pow, ast.USub,
)

def cel_to_py(expr: str) -> str:
    """
    Мини-трансляция подмножества CEL в Python-подобный синтаксис,
    рассчитанный на наш безопасный интерпретатор.
    Поддержка:
      - логические операторы &&, ||, !
      - литералы true/false/null
      - доступ к полям через точку/индексы оставляем как есть (мы разрешаем Attribute/Subscript)
      - in / not in — как в CEL
    """
    s = expr.strip()
    for pat, rep in _CEL_BOOL_REPLACERS:
        s = re.sub(pat, rep, s)
    for pat, rep in _CEL_OP_REPLACERS:
        s = re.sub(pat, rep, s)
    # Простейшая защита: запрет «()» вызовов (функций). CEL-функции не поддерживаем в этом адаптере.
    if re.search(r"[A-Za-z_][A-Za-z0-9_]*\s*\(", s):
        # (Допускаем только явные приведения вроде (a and b) — это скобки, не вызовы)
        # Нестрогое правило: если перед '(' нет оператора/скобки/пробела/точки/квадр. скобки — считаем вызовом.
        raise PolicyAdapterError("Function calls are not supported in CEL expressions for safety")
    return s

class SafeEvalError(Exception):
    pass

def safe_eval(expr_py: str, context: Mapping[str, Any]) -> bool:
    try:
        parsed = ast.parse(expr_py, mode="eval")
    except Exception as e:
        raise SafeEvalError(f"parse error: {e}")

    for node in ast.walk(parsed):
        if not isinstance(node, _ALLOWED_NODES):
            raise SafeEvalError(f"illegal node: {type(node).__name__}")
        if isinstance(node, ast.Attribute):
            # запретим «__» атрибуты
            if node.attr.startswith("__"):
                raise SafeEvalError("forbidden attribute")
        if isinstance(node, ast.Name):
            if node.id.startswith("__"):
                raise SafeEvalError("forbidden name")

    def _eval(n: ast.AST) -> Any:
        if isinstance(n, ast.Expression):
            return _eval(n.body)
        if isinstance(n, ast.Constant):
            return n.value
        if isinstance(n, ast.Name):
            return context.get(n.id)
        if isinstance(n, ast.Attribute):
            base = _eval(n.value)
            if isinstance(base, dict):
                return base.get(n.attr)
            return getattr(base, n.attr, None)
        if isinstance(n, ast.Subscript):
            base = _eval(n.value)
            if hasattr(n.slice, "value"):
                key = _eval(n.slice.value)
            else:
                key = _eval(n.slice)
            if isinstance(base, dict):
                return base.get(key)
            if isinstance(base, (list, tuple)) and isinstance(key, int):
                return base[key] if 0 <= key < len(base) else None
            return None
        if isinstance(n, ast.UnaryOp):
            val = _eval(n.operand)
            if isinstance(n.op, ast.Not):
                return not bool(val)
            if isinstance(n.op, ast.USub):
                return -val
            raise SafeEvalError("unsupported unary op")
        if isinstance(n, ast.BoolOp):
            if isinstance(n.op, ast.And):
                for v in n.values:
                    if not _eval(v):
                        return False
                return True
            if isinstance(n.op, ast.Or):
                for v in n.values:
                    if _eval(v):
                        return True
                return False
            raise SafeEvalError("unsupported bool op")
        if isinstance(n, ast.Compare):
            left = _eval(n.left)
            for op, comp in zip(n.ops, n.comparators):
                right = _eval(comp)
                ok = (
                    (isinstance(op, ast.Eq) and (left == right)) or
                    (isinstance(op, ast.NotEq) and (left != right)) or
                    (isinstance(op, ast.Gt) and (left > right)) or
                    (isinstance(op, ast.GtE) and (left >= right)) or
                    (isinstance(op, ast.Lt) and (left < right)) or
                    (isinstance(op, ast.LtE) and (left <= right)) or
                    (isinstance(op, ast.In) and (left in right if right is not None else False)) or
                    (isinstance(op, ast.NotIn) and (left not in right if right is not None else True)) or
                    (isinstance(op, ast.Is) and (left is right)) or
                    (isinstance(op, ast.IsNot) and (left is not right))
                )
                if not ok:
                    return False
                left = right
            return True
        if isinstance(n, ast.BinOp):
            l = _eval(n.left); r = _eval(n.right)
            if isinstance(n.op, ast.Add): return l + r
            if isinstance(n.op, ast.Sub): return l - r
            if isinstance(n.op, ast.Mult): return l * r
            if isinstance(n.op, ast.Div): return l / r
            if isinstance(n.op, ast.Mod): return l % r
            if isinstance(n.op, ast.Pow): return l ** r
            raise SafeEvalError("unsupported bin op")
        if isinstance(n, ast.Dict):
            return { _eval(k): _eval(v) for k, v in zip(n.keys, n.values) }
        if isinstance(n, ast.List):
            return [ _eval(x) for x in n.elts ]
        if isinstance(n, ast.Tuple):
            return tuple(_eval(x) for x in n.elts)
        raise SafeEvalError(f"unsupported node: {type(n).__name__}")
    return bool(_eval(parsed))

# =========================
# Предкомпиляция условий
# =========================

@dataclass(frozen=True)
class CompiledCondition:
    src: str
    expr_py: str
    ast_obj: ast.AST

    def evaluate(self, ctx: Mapping[str, Any]) -> bool:
        # Используем уже распарсенный AST, чтобы избежать парсинга на каждом вызове
        try:
            # Подменяем root и используем тот же интерпретатор (без повторной валидации)
            return safe_eval(self.expr_py, ctx)
        except SafeEvalError:
            return False

@lru_cache(maxsize=100_000)
def _compile_condition_cached(expr_src: str) -> CompiledCondition:
    expr_py = cel_to_py(expr_src)
    try:
        ast_obj = ast.parse(expr_py, mode="eval")
    except Exception as e:
        raise PolicyAdapterError(f"Condition compile error: {e}")
    # Валидация whitelist
    for node in ast.walk(ast_obj):
        if not isinstance(node, _ALLOWED_NODES):
            raise PolicyAdapterError(f"Condition contains illegal node: {type(node).__name__}")
    return CompiledCondition(src=expr_src, expr_py=expr_py, ast_obj=ast_obj)

def compile_condition(expr_src: Optional[str]) -> Optional[CompiledCondition]:
    if not expr_src:
        return None
    return _compile_condition_cached(expr_src.strip())

# =========================
# Компилированные сущности Policy/Rule
# =========================

@dataclass
class SubjectSelector:
    principals: Tuple[str, ...] = field(default_factory=tuple)
    roles: Tuple[str, ...] = field(default_factory=tuple)
    groups: Tuple[str, ...] = field(default_factory=tuple)
    attributes_eq: Mapping[str, Any] = field(default_factory=dict)
    match: Optional[CompiledCondition] = None

@dataclass
class ResourceSelector:
    type: Optional[str] = None
    ids: Tuple[str, ...] = field(default_factory=tuple)
    labels: Mapping[str, str] = field(default_factory=dict)
    attributes_eq: Mapping[str, Any] = field(default_factory=dict)
    match: Optional[CompiledCondition] = None

@dataclass
class Obligation:
    key: str
    value: Any

@dataclass
class CompiledRule:
    id: str
    effect: str  # "ALLOW" | "DENY"
    actions: Tuple[str, ...]
    subjects: Optional[SubjectSelector]
    resources: Optional[ResourceSelector]
    condition: Optional[CompiledCondition]
    obligations: Tuple[Obligation, ...]
    priority: int
    description: Optional[str] = None

@dataclass
class CompiledPolicy:
    name: str
    tenant_id: str
    priority: int
    rules: Tuple[CompiledRule, ...]
    applies_to_actions: Tuple[str, ...]
    labels: Mapping[str, str]
    etag: str

@dataclass
class PolicyMatch:
    policy_name: str
    rule_id: str
    effect: str
    matched: bool
    detail: str
    condition: Optional[str]
    policy_priority: int
    rule_priority: int

@dataclass
class EvaluationExplanation:
    decision: str  # "PERMIT"|"DENY"|"NOT_APPLICABLE"|"INDETERMINATE"
    reasons: List[str]
    matches: List[PolicyMatch]

@dataclass
class EvaluationResult:
    decision: str
    obligations: List[Obligation]
    explanation: Optional[EvaluationExplanation]
    bundle_etag: Optional[str]

@dataclass
class CompiledBundle:
    tenant_id: str
    policies: Tuple[CompiledPolicy, ...]
    etag: str
    # Индексы
    by_action: Dict[str, List[Tuple[int, CompiledPolicy, CompiledRule]]]  # action -> [(policy_priority, policy, rule)]
    by_res_type: Dict[str, List[Tuple[int, CompiledPolicy, CompiledRule]]]  # resource.type -> [...]
    lock: threading.RLock = field(default_factory=threading.RLock)

# =========================
# Нормализация/канонизация Policy → CompiledPolicy
# =========================

def _normalize_selector(sel: Optional[Mapping[str, Any]], is_subject: bool) -> Optional[SubjectSelector | ResourceSelector]:
    if not sel:
        return None
    s = _as_dict(sel)
    if is_subject:
        return SubjectSelector(
            principals=tuple(s.get("principals") or ()),
            roles=tuple(s.get("roles") or ()),
            groups=tuple(s.get("groups") or ()),
            attributes_eq=dict(s.get("attributes_eq") or {}),
            match=compile_condition(_maybe_expr(s.get("match"))),
        )
    else:
        return ResourceSelector(
            type=s.get("type"),
            ids=tuple(s.get("ids") or ()),
            labels=dict(s.get("labels") or {}),
            attributes_eq=dict(s.get("attributes_eq") or {}),
            match=compile_condition(_maybe_expr(s.get("match"))),
        )

def _maybe_expr(expr_or_expr_obj: Any) -> Optional[str]:
    # Поддержка google.type.Expr { expression: "...", description, title, location }
    if expr_or_expr_obj is None:
        return None
    if isinstance(expr_or_expr_obj, str):
        return expr_or_expr_obj
    if isinstance(expr_or_expr_obj, dict):
        return expr_or_expr_obj.get("expression") or expr_or_expr_obj.get("expr") or None
    # Pydantic/Proto с полем expression
    if hasattr(expr_or_expr_obj, "expression"):
        try:
            return str(getattr(expr_or_expr_obj, "expression"))
        except Exception:
            return None
    return None

def _normalize_rule(rule_in: Mapping[str, Any]) -> CompiledRule:
    r = _as_dict(rule_in)
    actions = tuple(sorted(set(r.get("actions") or ())))
    cond = compile_condition(_maybe_expr(r.get("condition")))
    subs = _normalize_selector(r.get("subjects"), is_subject=True)
    ress = _normalize_selector(r.get("resources"), is_subject=False)
    obligations = tuple(
        Obligation(key=str(o.get("key")), value=o.get("value"))
        for o in (r.get("obligations") or [])
        if isinstance(o, Mapping) and o.get("key")
    )
    return CompiledRule(
        id=str(r.get("id") or ""),
        effect=_to_str_effect(r.get("effect")),
        actions=actions,
        subjects=subs,
        resources=ress,
        condition=cond,
        obligations=obligations,
        priority=int(r.get("priority") or 0),
        description=r.get("description"),
    )

def _normalize_policy(pol_in: Mapping[str, Any]) -> CompiledPolicy:
    p = _as_dict(pol_in)
    name = str(p.get("name") or "")
    tenant_id = str(p.get("tenant_id") or p.get("tenant") or "")
    rules_in = p.get("rules") or []
    rules = tuple(sorted((_normalize_rule(r) for r in rules_in), key=lambda x: x.priority, reverse=True))
    applies = tuple(sorted(set(p.get("applies_to_actions") or ())))
    labels = dict(p.get("labels") or {})
    # ETag: каноническая копия без etag/signature/timestamp полей
    canon = {
        "name": name,
        "tenant_id": tenant_id,
        "priority": int(p.get("priority") or 0),
        "rules": [ _rule_to_canon(r) for r in rules ],
        "applies_to_actions": list(applies),
        "labels": labels,
        "version": _as_dict(p.get("version")) if p.get("version") else None,
        "disabled": bool(p.get("disabled", False)),
    }
    etag = compute_etag(canon)
    return CompiledPolicy(
        name=name,
        tenant_id=tenant_id,
        priority=int(p.get("priority") or 0),
        rules=rules,
        applies_to_actions=applies,
        labels=labels,
        etag=etag,
    )

def _rule_to_canon(r: CompiledRule) -> Mapping[str, Any]:
    return {
        "id": r.id,
        "effect": r.effect,
        "actions": list(r.actions),
        "subjects": {
            "principals": list(r.subjects.principals) if r.subjects else None,
            "roles": list(r.subjects.roles) if r.subjects else None,
            "groups": list(r.subjects.groups) if r.subjects else None,
            "attributes_eq": dict(r.subjects.attributes_eq) if r.subjects else None,
            "match": r.subjects.match.src if (r.subjects and r.subjects.match) else None,
        } if r.subjects else None,
        "resources": {
            "type": r.resources.type if r.resources else None,
            "ids": list(r.resources.ids) if r.resources else None,
            "labels": dict(r.resources.labels) if r.resources else None,
            "attributes_eq": dict(r.resources.attributes_eq) if r.resources else None,
            "match": r.resources.match.src if (r.resources and r.resources.match) else None,
        } if r.resources else None,
        "condition": r.condition.src if r.condition else None,
        "obligations": [ {"key": o.key, "value": o.value} for o in r.obligations ],
        "priority": r.priority,
        "description": r.description,
    }

# =========================
# Индексация бандла
# =========================

def _build_indexes(policies: Sequence[CompiledPolicy]) -> Tuple[Dict[str, List[Tuple[int, CompiledPolicy, CompiledRule]]],
                                                                Dict[str, List[Tuple[int, CompiledPolicy, CompiledRule]]]]:
    by_action: Dict[str, List[Tuple[int, CompiledPolicy, CompiledRule]]] = {}
    by_res_type: Dict[str, List[Tuple[int, CompiledPolicy, CompiledRule]]] = {}
    for p in policies:
        for r in p.rules:
            for a in r.actions:
                by_action.setdefault(a, []).append((p.priority, p, r))
            # индекс по типу ресурса (если задан)
            if r.resources and r.resources.type:
                by_res_type.setdefault(r.resources.type, []).append((p.priority, p, r))
    # сортировка: по приоритету политики desc, затем правил desc
    for k in by_action:
        by_action[k].sort(key=lambda t: (t[0], t[2].priority), reverse=True)
    for k in by_res_type:
        by_res_type[k].sort(key=lambda t: (t[0], t[2].priority), reverse=True)
    return by_action, by_res_type

# =========================
# Сопоставление селекторов
# =========================

def _match_subject(sel: Optional[SubjectSelector], subject: Mapping[str, Any], session: Mapping[str, Any], env: Mapping[str, Any]) -> Tuple[bool, str]:
    if sel is None:
        return True, "no subject selector"
    pid = subject.get("principal_id") or subject.get("id")
    roles = set(subject.get("roles") or ())
    groups = set(subject.get("groups") or ())
    if sel.principals and pid not in sel.principals:
        return False, "principal mismatch"
    if sel.roles and not roles.intersection(sel.roles):
        return False, "role mismatch"
    if sel.groups and not groups.intersection(sel.groups):
        return False, "group mismatch"
    for k, v in sel.attributes_eq.items():
        if (subject.get("attributes") or {}).get(k) != v:
            return False, f"subject attr {k} mismatch"
    if sel.match:
        ctx = {
            "subject": subject,
            "session": session or {},
            "env": env or {},
        }
        try:
            if not sel.match.evaluate(ctx):
                return False, "subject match false"
        except Exception as e:
            return False, f"subject match error: {e}"
    return True, "subject matched"

def _match_resource(sel: Optional[ResourceSelector], resource: Mapping[str, Any], env: Mapping[str, Any]) -> Tuple[bool, str]:
    if sel is None:
        return True, "no resource selector"
    if sel.type and resource.get("type") != sel.type:
        return False, "type mismatch"
    if sel.ids and resource.get("id") not in sel.ids:
        return False, "id mismatch"
    labels = resource.get("labels") or {}
    for lk, lv in sel.labels.items():
        if labels.get(lk) != lv:
            return False, f"label {lk} mismatch"
    attrs = resource.get("attributes") or {}
    for k, v in sel.attributes_eq.items():
        if attrs.get(k) != v:
            return False, f"resource attr {k} mismatch"
    if sel.match:
        ctx = { "resource": resource, "env": env or {} }
        try:
            if not sel.match.evaluate(ctx):
                return False, "resource match false"
        except Exception as e:
            return False, f"resource match error: {e}"
    return True, "resource matched"

# =========================
# Адаптер
# =========================

class PolicyAdapter:
    """
    Превращает политики в предкомпилированный бандл и выполняет оценку.
    Потокобезопасен на чтение; пересборка бандла — под локом.
    """
    def __init__(self) -> None:
        self._lock = threading.RLock()
        self._bundles: Dict[str, CompiledBundle] = {}

    # ----------- Компиляция -----------
    def compile_bundle(self, tenant_id: str, policies_in: Iterable[Any]) -> CompiledBundle:
        normalized: List[CompiledPolicy] = []
        for p in policies_in:
            cp = _normalize_policy(p)
            if cp.tenant_id != tenant_id:
                # безопаснее отсеять
                continue
            # игнорируем отключённые политики, если этот флаг присутствует в исходной структуре
            src = _as_dict(p)
            if bool(src.get("disabled", False)):
                continue
            normalized.append(cp)
        # сортировка политик по приоритету
        normalized.sort(key=lambda p: p.priority, reverse=True)
        etag = compute_etag([p.etag for p in normalized])
        by_action, by_res_type = _build_indexes(normalized)
        bundle = CompiledBundle(
            tenant_id=tenant_id,
            policies=tuple(normalized),
            etag=etag,
            by_action=by_action,
            by_res_type=by_res_type,
        )
        with self._lock:
            self._bundles[tenant_id] = bundle
        return bundle

    def get_bundle(self, tenant_id: str) -> Optional[CompiledBundle]:
        with self._lock:
            return self._bundles.get(tenant_id)

    # ----------- Оценка -----------
    def evaluate(
        self,
        tenant_id: str,
        *,
        subject: Mapping[str, Any],
        resource: Mapping[str, Any],
        action: str,
        session: Optional[Mapping[str, Any]] = None,
        env: Optional[Mapping[str, Any]] = None,
        mode: str = "DEFAULT",
        include_explanation: bool = False,
        include_obligations: bool = True,
        policy_names: Optional[Sequence[str]] = None,
        request_id: Optional[str] = None,
    ) -> EvaluationResult:
        bundle = self.get_bundle(tenant_id)
        if not bundle:
            # default deny
            return EvaluationResult(
                decision="DENY" if mode in ("DEFAULT", "DENY_BIASED") else "NOT_APPLICABLE",
                obligations=[],
                explanation=EvaluationExplanation(decision="DENY", reasons=["no bundle"], matches=[]) if include_explanation else None,
                bundle_etag=None,
            )

        with bundle.lock:
            matches: List[PolicyMatch] = []
            obligations: List[Obligation] = []
            permit_found = False
            deny_found = False
            reasons: List[str] = []

            # Предвыборка по action и типу ресурса
            candidates = list(bundle.by_action.get(action, []))
            rtype = resource.get("type")
            if rtype:
                # объединим кандидатов по ресурсу, сохраняя порядок по приоритету
                candidates = _merge_unique(candidates, bundle.by_res_type.get(rtype, []))

            # Фильтрация политики по списку имён
            allowed_names = set(policy_names or [])
            def _policy_allowed(p: CompiledPolicy) -> bool:
                return (not allowed_names) or (p.name in allowed_names)

            for pprio, p, r in candidates:
                if not _policy_allowed(p):
                    continue
                if action not in r.actions:
                    continue
                # Subject
                s_ok, s_reason = _match_subject(r.subjects, subject, session or {}, env or {})
                if not s_ok:
                    matches.append(PolicyMatch(p.name, r.id, r.effect, False, s_reason, r.condition.src if r.condition else None, p.priority, r.priority))
                    continue
                # Resource
                r_ok, r_reason = _match_resource(r.resources, resource, env or {})
                if not r_ok:
                    matches.append(PolicyMatch(p.name, r.id, r.effect, False, r_reason, r.condition.src if r.condition else None, p.priority, r.priority))
                    continue
                # Condition
                cond_ok = True
                detail = "no condition"
                if r.condition:
                    ctx = {
                        "subject": subject,
                        "resource": resource,
                        "action": action,
                        "session": session or {},
                        "env": env or {},
                    }
                    try:
                        cond_ok = r.condition.evaluate(ctx)
                        detail = "condition true" if cond_ok else "condition false"
                    except Exception as e:
                        cond_ok = False
                        detail = f"condition error: {e}"
                if not cond_ok:
                    matches.append(PolicyMatch(p.name, r.id, r.effect, False, detail, r.condition.src if r.condition else None, p.priority, r.priority))
                    continue

                # Успешный матч
                matches.append(PolicyMatch(p.name, r.id, r.effect, True, "matched", r.condition.src if r.condition else None, p.priority, r.priority))
                if r.effect == "DENY":
                    deny_found = True
                    reasons.append(f"deny by {p.name}/{r.id}")
                    break  # DENY имеет приоритет
                else:
                    permit_found = True
                    if include_obligations and r.obligations:
                        obligations.extend(r.obligations)

            if deny_found:
                decision = "DENY"
                reasons = reasons or ["explicit deny"]
            elif permit_found:
                decision = "PERMIT"
                reasons = reasons or ["explicit permit"]
            else:
                decision = "DENY" if mode in ("DEFAULT", "DENY_BIASED") else "NOT_APPLICABLE"
                reasons = ["no matching rule"]

            explanation = EvaluationExplanation(decision=decision, reasons=reasons, matches=matches) if include_explanation else None
            return EvaluationResult(decision=decision, obligations=obligations if decision == "PERMIT" else [], explanation=explanation, bundle_etag=bundle.etag)

# =========================
# Вспомогательное
# =========================

def _merge_unique(a: List[Tuple[int, CompiledPolicy, CompiledRule]], b: List[Tuple[int, CompiledPolicy, CompiledRule]]) -> List[Tuple[int, CompiledPolicy, CompiledRule]]:
    """
    Объединяет два списка кандидатов, сохраняя порядок по (policy.priority, rule.priority) desc и убирая дубли правил.
    """
    seen = set()
    out: List[Tuple[int, CompiledPolicy, CompiledRule]] = []
    def _add(lst):
        for item in lst:
            _, p, r = item
            key = (p.name, r.id)
            if key in seen:
                continue
            seen.add(key)
            out.append(item)
    _add(a); _add(b)
    # по идее входы уже отсортированы; доп. сортировка на случай объединения из разных индексов
    out.sort(key=lambda t: (t[0], t[2].priority), reverse=True)
    return out

# =========================
# Пример использования
# =========================
#
# adapter = PolicyAdapter()
# bundle = adapter.compile_bundle("acme", [policy_dict_1, policy_dict_2])
# result = adapter.evaluate(
#     "acme",
#     subject={"tenant_id": "acme", "principal_id": "u:alice", "roles": ["analyst"], "attributes": {"geo": "SE"}},
#     resource={"type": "dataset", "id": "ds1", "labels": {"classification": "public"}, "attributes": {}},
#     action="read",
#     session={"mfa_level": 3, "risk_score": 7.5},
#     env={"ip": "10.1.2.3"},
#     include_explanation=True,
# )
# assert result.decision in ("PERMIT", "DENY")
