// ledger-core/schemas/proto/v1/ledger/proof.proto
syntax = "proto3";

package ledger.v1.ledger;

option csharp_namespace = "Ledger.V1";
option go_package       = "github.com/example/ledger-core/gen/ledger/v1;ledgerv1";
option java_multiple_files = true;
option java_package        = "org.example.ledger.v1";
option java_outer_classname = "ProofProto";
option objc_class_prefix    = "LDG";
option optimize_for         = SPEED;

// Внешние зависимости
import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";

// ------------------------------------------------------------
// БАЗОВЫЕ ТИПЫ И ПЕРЕЧИСЛЕНИЯ
// ------------------------------------------------------------

/**
 * Алгоритмы хеширования. Значения запинены; новые добавлять в конец.
 */
enum HashAlgorithm {
  HASH_ALGORITHM_UNSPECIFIED = 0;
  HASH_ALGORITHM_SHA256      = 1;
  HASH_ALGORITHM_SHA512      = 2;
  HASH_ALGORITHM_BLAKE2B_256 = 3;
  HASH_ALGORITHM_KECCAK256   = 4;
  // reserved 100 to 199; // для кастомных корпоративных алгоритмов
}

/**
 * Типы публичных ключей/схем подписи.
 */
enum SignatureAlgorithm {
  SIGNATURE_ALGORITHM_UNSPECIFIED = 0;
  SIGNATURE_ALGORITHM_ED25519     = 1;
  SIGNATURE_ALGORITHM_ECDSA_P256  = 2;
  SIGNATURE_ALGORITHM_ECDSA_SECP256K1 = 3;
  SIGNATURE_ALGORITHM_RSA_PSS_SHA256   = 4;
  // reserved 100 to 199;
}

/**
 * Политика кворума для мультиподписей.
 */
enum QuorumPolicy {
  QUORUM_POLICY_UNSPECIFIED = 0;
  QUORUM_POLICY_M_OF_N      = 1; // требуется threshold из N
}

/**
 * Позиция узла в ветке Merkle.
 */
enum MerkleSide {
  MERKLE_SIDE_UNSPECIFIED = 0;
  MERKLE_SIDE_LEFT        = 1;
  MERKLE_SIDE_RIGHT       = 2;
}

/**
 * Тип контента/субъекта доказательства.
 */
enum SubjectType {
  SUBJECT_TYPE_UNSPECIFIED = 0;
  SUBJECT_TYPE_TRANSACTION = 1; // запись/проводка
  SUBJECT_TYPE_DOCUMENT    = 2; // произвольный документ/заявление
  SUBJECT_TYPE_STATE       = 3; // состояние счета/баланса
  SUBJECT_TYPE_BLOCK       = 4; // целый блок
  // reserved 100 to 199;
}

/**
 * Тип источника якоря/цепи.
 */
enum AnchorChain {
  ANCHOR_CHAIN_UNSPECIFIED = 0;
  ANCHOR_CHAIN_INTERNAL    = 1; // внутренняя цепь ledger-core
  ANCHOR_CHAIN_ETHEREUM    = 2;
  ANCHOR_CHAIN_BITCOIN     = 3;
  ANCHOR_CHAIN_OTHER       = 4;
}

/**
 * Статус валидации (для кэша результатов проверки).
 */
enum ValidationStatus {
  VALIDATION_STATUS_UNSPECIFIED = 0;
  VALIDATION_STATUS_PASSED      = 1;
  VALIDATION_STATUS_FAILED      = 2;
  VALIDATION_STATUS_INDETERMINATE = 3; // недостаточно данных
}

// ------------------------------------------------------------
// ОБЩИЕ СТРУКТУРЫ
// ------------------------------------------------------------

/**
 * Унифицированный дайджест.
 */
message Digest {
  HashAlgorithm algorithm = 1;
  bytes value             = 2; // сырой байтовый дайджест (fixed_len зависит от алгоритма)
}

/**
 * Идентификатор ключа/подписанта.
 */
message KeyIdentity {
  // Условное имя/идентификатор ключа (KID, thumbprint, fingerprint).
  string key_id = 1;
  // Алгоритм подписи, которому соответствует public_key.
  SignatureAlgorithm algorithm = 2;
  // Публичный ключ в DER/RAW представлении в зависимости от алгоритма.
  bytes public_key = 3;
  // Доп. метаданные (iss, sub и т. п. для OIDC/JWT‑based подписи).
  map<string, string> attributes = 4;
}

/**
 * Ссылка на блок/якорь в цепи.
 */
message BlockHeaderRef {
  AnchorChain chain            = 1;
  string chain_id              = 2; // например, "mainnet", "goerli", "internal-ledger"
  uint64 height                = 3; // номер блока/высота
  Digest block_hash            = 4;
  google.protobuf.Timestamp time = 5;
  // Опциональные поля специфичные для цепи (например, txid якорения).
  map<string, string> attributes = 10;
}

/**
 * Универсальная запись аудита (кто/когда/где оформил доказательство).
 */
message Attestation {
  string issuer                = 1; // субъект, выпустивший доказательство (URN/URL/DID)
  string purpose               = 2; // человеко‑читаемая цель (например, "posting inclusion proof")
  google.protobuf.Timestamp time = 3;
  map<string, string> attributes = 10; // контекст: регион, регулятор и т. п.
}

// ------------------------------------------------------------
// ПРОВОДИМЫЕ ДОКАЗАТЕЛЬСТВА
// ------------------------------------------------------------

/**
 * Подпись одного подписанта.
 */
message Signature {
  SignatureAlgorithm algorithm = 1;
  KeyIdentity signer           = 2;
  bytes signature              = 3; // сырой байтовый подп. артефакт (для RSA‑PSS — DER или RAW)
  bytes message_digest         = 4; // дайджест подписанного сообщения (если подписывается digest)
  bytes context                = 5; // доменный сепаратор/префикс (domain separation tag), nonce и т. п.
  // reserved 100 to 149;
}

/**
 * Мультиподпись с кворумом.
 */
message MultiSignature {
  QuorumPolicy policy          = 1;
  uint32 threshold_m           = 2; // скольких подписей достаточно
  uint32 participants_n        = 3; // общее число участников
  repeated Signature signatures = 4; // собранные подписи (не обязаны включать всех участников)
  // reserved 100 to 149;
}

/**
 * Узел пути Merkle: соседний хеш и его сторона.
 */
message MerkleNode {
  MerkleSide side = 1;
  Digest hash     = 2;
}

/**
 * Доказательство включения в дерево Merkle.
 */
message MerkleProof {
  HashAlgorithm hash_algorithm = 1;     // алгоритм для построения дерева
  Digest root                  = 2;     // известный корень
  Digest leaf                  = 3;     // лист (обычно хеш сериализованного субъекта)
  repeated MerkleNode path     = 4;     // путь от листа к корню
  uint32 tree_arity            = 5;     // 2 для бинарного, >2 для M‑арности
  // Опциональная привязка к блочному заголовку/якорю
  BlockHeaderRef anchored_at   = 10;
  // reserved 100 to 149;
}

// ------------------------------------------------------------
// СУБЪЕКТ ДОКАЗАТЕЛЬСТВА
// ------------------------------------------------------------

/**
 * Что именно мы доказываем — унифицированный идентификатор и его дайджест.
 * Например, идентификатор транзакции и хеш сериализованной записи.
 */
message Subject {
  SubjectType type     = 1;
  string id            = 2; // глобальный идентификатор (URN/UUID/TxID)
  Digest digest        = 3; // дайджест сериализованного состояния/записи
  map<string, string> attributes = 10; // любая доп. контекстная информация
}

// ------------------------------------------------------------
// ОБЩАЯ ОБВЁРТКА ДОКАЗАТЕЛЬСТВА
// ------------------------------------------------------------

/**
 * Конверт доказательства с версионированием и типизацией.
 * oneof гарантирует, что одновременно установлен только один вид доказательства.
 */
message ProofEnvelope {
  // Версия схемы/конверта — для мягкой эволюции формата.
  uint32 schema_version = 1;

  // Идентификатор и дайджест того, что доказываем.
  Subject subject = 2;

  // Источник/генератор доказательства и его аттестация.
  Attestation issued_by = 3;

  // Жёсткая привязка ко времени генерации/получения доказательства.
  google.protobuf.Timestamp issued_at = 4;

  // Срок «годности» (например, для подписи токена/утверждения).
  google.protobuf.Duration valid_for = 5;

  // Куда якорится доказательство (блок/цепь), если применимо.
  BlockHeaderRef anchor = 6;

  // Результат последней валидации (кэш), не влияет на проверку.
  ValidationStatus last_validation_status = 7;

  // Внутренние/внешние метаданные; ключи snake_case.
  map<string, string> metadata = 8;

  // Собственно доказательство (ровно один вариант).
  oneof proof {
    MerkleProof merkle      = 20;
    Signature  signature    = 21;
    MultiSignature multisig = 22;
    // reserved 100 to 149; // для будущих типов (например, ZK‑доказательства)
  }

  // Резервируем диапазоны под будущее расширение без wire‑конфликтов.
  reserved 90 to 99;   // внутренние служебные поля
  reserved 150 to 199; // будущие общие поля конверта
}

// ------------------------------------------------------------
// УТИЛИТАРНЫЕ КОНТЕЙНЕРЫ/РЕЗУЛЬТАТЫ ПРОВЕРОК
// ------------------------------------------------------------

/**
 * Запрос на валидацию: что и как проверять.
 * Может использоваться сервисами валидации на стороне сервера.
 */
message ProofValidationRequest {
  ProofEnvelope envelope      = 1;
  // Опциональные политики/ограничения (например, какие CA/ключи доверены).
  map<string, string> policy  = 2;
}

/**
 * Ответ валидации с детальным логом шагов.
 */
message ProofValidationResult {
  ValidationStatus status = 1;
  string message          = 2; // краткая сводка
  repeated Step steps     = 3; // подробные шаги проверки

  message Step {
    string name   = 1;         // например, "check_digest", "verify_signature"
    bool   ok     = 2;
    string detail = 3;         // человеко‑читаемое объяснение
  }
}

// ------------------------------------------------------------
// ДОГОВОРЫ О БЭКВАРД‑СОВМЕСТИМОСТИ (важно для промышленности)
// ------------------------------------------------------------
// 1) Не переиспользовать удалённые номера полей — только reserve.
// 2) Новые enum‑значения добавлять в конец; клиенты должны уметь игнорировать неизвестные.
// 3) Не делать поля required: в proto3 их нет; используем разумные дефолты.
// 4) Для бинарной стабильности все bytes — в «сыром» виде; формат описывается полями алгоритмов.
// 5) Метаданные — исключительно в map<string,string>, чтобы не ломать контракт при расширении.
