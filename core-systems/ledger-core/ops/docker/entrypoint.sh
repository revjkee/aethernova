#!/usr/bin/env bash
# ledger-core / ops/docker/entrypoint.sh
# Industrial entrypoint for containers (PID 1, signal-safe, stdlib-only)

set -Eeuo pipefail

### ----------------------------
### Globals / Defaults
### ----------------------------
APP_NAME="${APP_NAME:-ledger-core}"
APP_ENV="${APP_ENV:-production}"
APP_USER="${APP_USER:-ledger}"
APP_DIR="${APP_DIR:-/app}"
DATA_DIR="${DATA_DIR:-/data}"
RUNTIME_DIR="${RUNTIME_DIR:-/run/ledger}"
CONFIG_DIR="${CONFIG_DIR:-/etc/ledger}"
CONFIG_FILE="${CONFIG_FILE:-$CONFIG_DIR/config.yaml}"
MIGRATIONS_DIR="${DB_MIGRATIONS_DIR:-$APP_DIR/migrations}"
LOG_LEVEL="${LOG_LEVEL:-info}"
UMASK_VALUE="${UMASK_VALUE:-0027}"
SHUTDOWN_GRACE="${APP_SHUTDOWN_GRACE_SECONDS:-20}"

# Services (optional)
DB_HOST="${DB_HOST:-localhost}"
DB_PORT="${DB_PORT:-5432}"
REDIS_URL="${REDIS_URL:-}"
KAFKA_BROKERS="${KAFKA_BROKERS:-}"
NATS_URL="${NATS_URL:-}"
OTEL_ENDPOINT="${OTEL_EXPORTER_OTLP_ENDPOINT:-}"

# Runtime toggles
ENABLE_MIGRATE_ON_START="${DB_MIGRATE_ON_START:-true}"
ENABLE_TEMPLATE_CONFIG="${ENABLE_TEMPLATE_CONFIG:-true}"
HEALTH_PORT="${HEALTH_PORT:-8081}"

### ----------------------------
### Logging
### ----------------------------
log() {
  # level msg [k=v...]
  local level="$1"; shift
  local msg="$1"; shift || true
  local ts
  ts="$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
  # shellcheck disable=SC2128
  local extra="$*"
  printf '{"ts":"%s","level":"%s","app":"%s","msg":"%s"%s}\n' \
    "$ts" "$level" "$APP_NAME" "$msg" "$( [[ -n "$extra" ]] && printf ',%s' "$extra" || true )"
}

info(){ log info "$@"; }
warn(){ log warn "$@"; }
err(){  log error "$@"; }

### ----------------------------
### Trap / Reap (PID 1)
### ----------------------------
children=()

reap() {
  # Reap any zombie children
  while true; do
    # -n: do not block, -p: return PID of reaped child
    if ! pid=$(wait -n 2>/dev/null); then
      break
    fi
    info "child_reaped" "pid=$pid"
  done
}

term() {
  warn "signal_received" "sig=TERM" "grace=${SHUTDOWN_GRACE}s"
  for pid in "${children[@]:-}"; do
    if kill -0 "$pid" 2>/dev/null; then
      kill -TERM "$pid" 2>/dev/null || true
    fi
  done
  SECONDS=0
  while [[ $SECONDS -lt "$SHUTDOWN_GRACE" ]]; do
    alive=0
    for pid in "${children[@]:-}"; do
      if kill -0 "$pid" 2>/dev/null; then alive=1; fi
    done
    [[ $alive -eq 0 ]] && break
    sleep 1
  done
  exit 0
}

trap 'reap' CHLD
trap 'term' TERM
trap 'exit 130' INT

### ----------------------------
### Utilities
### ----------------------------
env_from_file() {
  # Usage: env_from_file VAR [DEFAULT]
  local var="$1"; local def="${2:-}"
  local file_var="${var}_FILE"
  local val="${!var:-}"
  local file="${!file_var:-}"
  if [[ -n "$val" && -n "$file" ]]; then
    err "env_conflict" "var=$var" "file_var=$file_var"
    exit 64
  fi
  if [[ -n "$file" ]]; then
    if [[ -r "$file" ]]; then
      val="$(<"$file")"
    else
      err "env_file_unreadable" "file=$file"
      exit 66
    fi
  fi
  export "$var"="${val:-$def}"
  unset "$file_var"
}

require_env() {
  local var="$1"
  if [[ -z "${!var:-}" ]]; then
    err "env_missing" "var=$var"
    exit 64
  fi
}

retry() {
  # retry <attempts> <sleep_seconds> -- cmd...
  local attempts="$1"; shift
  local sleep_s="$1"; shift
  local n=1
  until "$@"; then
    if (( n >= attempts )); then
      return 1
    fi
    warn "retrying" "attempt=$((n+1))" "sleep=${sleep_s}s" "cmd=$*"
    sleep "$sleep_s"
    n=$(( n + 1 ))
  done
  return 0
}

wait_for_tcp() {
  # wait_for_tcp host port timeout_seconds
  local host="$1" port="$2" timeout="$3"
  info "wait_for_tcp" "host=$host" "port=$port" "timeout=${timeout}s"
  SECONDS=0
  while ! (echo >"/dev/tcp/$host/$port") >/dev/null 2>&1; do
    [[ $SECONDS -ge $timeout ]] && return 1
    sleep 1
  done
  return 0
}

template_config() {
  [[ "$ENABLE_TEMPLATE_CONFIG" == "true" ]] || { info "template_config_skipped"; return 0; }
  mkdir -p "$CONFIG_DIR"
  if [[ ! -f "$CONFIG_FILE" ]]; then
    info "generate_config" "path=$CONFIG_FILE"
    cat >"$CONFIG_FILE" <<'YAML'
# Autogenerated by entrypoint on first run
app:
  name: ${APP_NAME}
  env: ${APP_ENV}
  log_level: ${LOG_LEVEL}
server:
  bind: ${APP_BIND:-0.0.0.0}
  port: ${APP_PORT:-8080}
database:
  host: ${DB_HOST}
  port: ${DB_PORT}
  name: ${DB_NAME:-ledger}
  user: ${DB_USER:-ledger_app}
  password: ${DB_PASSWORD:-}
  sslmode: ${DB_SSLMODE:-disable}
redis:
  url: ${REDIS_URL:-}
kafka:
  brokers: ${KAFKA_BROKERS:-}
nats:
  url: ${NATS_URL:-}
otel:
  endpoint: ${OTEL_EXPORTER_OTLP_ENDPOINT:-}
YAML
  else
    info "config_exists" "path=$CONFIG_FILE"
  fi
}

drop_privileges() {
  local target_user="$1"
  if [[ "$(id -u)" -eq 0 ]]; then
    if command -v gosu >/dev/null 2>&1; then
      exec gosu "$target_user" "$@"
    elif command -v su-exec >/dev/null 2>&1; then
      exec su-exec "$target_user" "$@"
    else
      # Fallback: run via su -s
      exec su -s /bin/sh -c "$*"
    fi
  else
    exec "$@"
  fi
}

### ----------------------------
### Pre-flight
### ----------------------------
umask "$UMASK_VALUE" || true

# Read secrets via *_FILE pattern
env_from_file SECRET_KEY_BASE "change_me"
env_from_file DB_PASSWORD ""
env_from_file JWT_PRIVATE_KEY_PATH ""
env_from_file JWT_PUBLIC_KEY_PATH ""
env_from_file WEBHOOK_SIGN_SECRET ""

# Validate minimal set for production
if [[ "$APP_ENV" == "production" ]]; then
  require_env SECRET_KEY_BASE
fi

mkdir -p "$DATA_DIR" "$RUNTIME_DIR" "$CONFIG_DIR"

template_config

### ----------------------------
### Dependencies readiness
### ----------------------------
wait_deps() {
  # DB
  if [[ -n "${DB_HOST:-}" && -n "${DB_PORT:-}" ]]; then
    retry 30 2 wait_for_tcp "$DB_HOST" "$DB_PORT" 2 || {
      err "wait_db_failed" "host=$DB_HOST" "port=$DB_PORT"
      exit 70
    }
  fi
  # Redis
  if [[ -n "${REDIS_URL:-}" ]]; then
    # redis://host:port/db
    REDIS_HOST="$(echo "$REDIS_URL" | sed -E 's#^redis://([^:/]+).*#\1#')"
    REDIS_PORT="$(echo "$REDIS_URL" | sed -E 's#^redis://[^:]+:([0-9]+).*#\1#')"
    if [[ -n "$REDIS_HOST" && -n "$REDIS_PORT" ]]; then
      retry 30 2 wait_for_tcp "$REDIS_HOST" "$REDIS_PORT" 2 || warn "wait_redis_failed" "url=$REDIS_URL"
    fi
  fi
  # Kafka
  if [[ -n "${KAFKA_BROKERS:-}" ]]; then
    IFS=',' read -r -a brokers <<< "$KAFKA_BROKERS"
    for b in "${brokers[@]}"; do
      host="${b%%:*}"; port="${b##*:}"
      retry 15 2 wait_for_tcp "$host" "$port" 2 || warn "wait_kafka_failed" "broker=$b"
    done
  fi
  # NATS
  if [[ -n "${NATS_URL:-}" ]]; then
    # nats://host:port
    NATS_HOST="$(echo "$NATS_URL" | sed -E 's#^nats://([^:/]+).*#\1#')"
    NATS_PORT="$(echo "$NATS_URL" | sed -E 's#^nats://[^:]+:([0-9]+).*#\1#')"
    if [[ -n "$NATS_HOST" && -n "$NATS_PORT" ]]; then
      retry 15 2 wait_for_tcp "$NATS_HOST" "$NATS_PORT" 2 || warn "wait_nats_failed" "url=$NATS_URL"
    fi
  fi
  # OTel collector (optional)
  if [[ -n "${OTEL_ENDPOINT:-}" ]]; then
    hostport="${OTEL_ENDPOINT#http://}"; hostport="${hostport#https://}"
    host="${hostport%%:*}"; port="${hostport##*:}"
    if [[ "$host" != "$port" ]]; then
      retry 10 2 wait_for_tcp "$host" "$port" 2 || warn "wait_otel_failed" "endpoint=$OTEL_ENDPOINT"
    fi
  fi
}

### ----------------------------
### Database migrations
### ----------------------------
run_migrations() {
  if [[ "$ENABLE_MIGRATE_ON_START" != "true" ]]; then
    info "migrations_skipped"
    return 0
  fi
  if [[ ! -d "$MIGRATIONS_DIR" ]]; then
    warn "migrations_dir_missing" "path=$MIGRATIONS_DIR"
    return 0
  fi

  info "migrations_start" "dir=$MIGRATIONS_DIR"
  # Tool-agnostic: prefer internal binary, else alembic, else goose, else sqlx, else noop
  if command -v "$APP_DIR/ledger-migrate" >/dev/null 2>&1; then
    retry 5 3 "$APP_DIR/ledger-migrate" up --dir "$MIGRATIONS_DIR"
  elif command -v alembic >/dev/null 2>&1; then
    (cd "$APP_DIR" && retry 5 3 alembic upgrade head)
  elif command -v goose >/dev/null 2>&1; then
    retry 5 3 goose -dir "$MIGRATIONS_DIR" postgres "host=$DB_HOST port=$DB_PORT dbname=${DB_NAME:-ledger} user=${DB_USER:-ledger_app} password=${DB_PASSWORD:-}" up
  elif command -v sqlx >/dev/null 2>&1; then
    retry 5 3 sqlx migrate run --source "$MIGRATIONS_DIR"
  else
    warn "no_migration_tool_found"
    return 0
  fi
  info "migrations_done"
}

### ----------------------------
### Health / Ready endpoints (exec-only)
### ----------------------------
cmd_health() {
  # return 0 if the process is healthy (basic checks)
  [[ -f "$CONFIG_FILE" ]] || { err "health_config_missing" "path=$CONFIG_FILE"; return 1; }
  # optional tcp checks
  if ! (echo >"/dev/tcp/$DB_HOST/$DB_PORT") >/dev/null 2>&1; then
    err "health_db_unreachable" "host=$DB_HOST" "port=$DB_PORT"
    return 2
  fi
  info "health_ok" "env=$APP_ENV"
  return 0
}

cmd_ready() {
  # readiness: extend with app-specific probe if needed
  cmd_health
}

### ----------------------------
### Command modes
### ----------------------------
start_web() {
  wait_deps
  run_migrations
  info "starting_web" "user=$APP_USER" "env=$APP_ENV" "config=$CONFIG_FILE"
  # Example web binary or module runner; replace with your real start command:
  local cmd=("$APP_DIR/bin/ledger-web" "--config=$CONFIG_FILE" "--log-level=$LOG_LEVEL")
  if [[ ! -x "${cmd[0]}" ]]; then
    # Fallback: Python/Gunicorn example
    cmd=(python -m ledger_core.web "--config=$CONFIG_FILE" "--log-level=$LOG_LEVEL")
  fi
  if [[ "$(id -u)" -eq 0 ]]; then
    children=()
    if command -v gosu >/dev/null 2>&1; then
      gosu "$APP_USER" "${cmd[@]}" &
    else
      su -s /bin/sh -c "${cmd[*]}" "$APP_USER" &
    fi
    children+=("$!")
    wait
  else
    exec "${cmd[@]}"
  fi
}

start_worker() {
  wait_deps
  run_migrations
  info "starting_worker" "user=$APP_USER"
  local cmd=("$APP_DIR/bin/ledger-worker" "--config=$CONFIG_FILE" "--log-level=$LOG_LEVEL")
  if [[ ! -x "${cmd[0]}" ]]; then
    cmd=(python -m ledger_core.worker "--config=$CONFIG_FILE" "--log-level=$LOG_LEVEL")
  fi
  if [[ "$(id -u)" -eq 0 ]]; then
    "${cmd[@]}" & children+=("$!"); wait
  else
    exec "${cmd[@]}"
  fi
}

start_scheduler() {
  wait_deps
  run_migrations
  info "starting_scheduler" "user=$APP_USER"
  local cmd=("$APP_DIR/bin/ledger-scheduler" "--config=$CONFIG_FILE" "--log-level=$LOG_LEVEL")
  if [[ ! -x "${cmd[0]}" ]]; then
    cmd=(python -m ledger_core.scheduler "--config=$CONFIG_FILE" "--log-level=$LOG_LEVEL")
  fi
  if [[ "$(id -u)" -eq 0 ]]; then
    "${cmd[@]}" & children+=("$!"); wait
  else
    exec "${cmd[@]}"
  fi
}

start_shell() {
  info "starting_shell" "user=$APP_USER"
  if [[ "$(id -u)" -eq 0 ]]; then
    exec gosu "$APP_USER" /bin/sh -l
  else
    exec /bin/sh -l
  fi
}

start_migrate() {
  wait_deps
  run_migrations
}

### ----------------------------
### Main dispatch
### ----------------------------
main() {
  # Normalize args: default -> web
  local sub="${1:-web}"; shift || true

  case "$sub" in
    web)        start_web "$@" ;;
    worker)     start_worker "$@" ;;
    scheduler)  start_scheduler "$@" ;;
    migrate)    start_migrate "$@" ;;
    shell)      start_shell "$@" ;;
    health)     cmd_health "$@" ;;
    ready)      cmd_ready "$@" ;;
    *)
      # Fallback: execute arbitrary command (for debug/compat)
      info "exec_passthrough" "cmd=$sub $*"
      exec "$sub" "$@"
      ;;
  esac
}

main "$@"
