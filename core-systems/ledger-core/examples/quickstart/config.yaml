# Ledger-core quickstart configuration (industrial-grade defaults)
# File: examples/quickstart/config.yaml

version: 1

app:
  name: ledger-core
  environment: ${APP_ENV:dev}            # dev|staging|prod
  region: ${APP_REGION:eu-central}
  instance_id: ${APP_INSTANCE_ID:auto}   # auto -> generated at runtime
  timezone: ${APP_TZ:UTC}
  # Strict mode forces validation and aborts on partial misconfig
  strict_mode: ${APP_STRICT:true}

runtime:
  # Graceful shutdown timeout for services
  shutdown_timeout_s: ${RUNTIME_SHUTDOWN_S:25}
  uvloop: ${RUNTIME_UVLOOP:true}
  http_server:
    host: ${HTTP_HOST:0.0.0.0}
    port: ${HTTP_PORT:8080}
    # Read/Write/Idle timeouts protect from slowloris
    read_timeout_s: ${HTTP_READ_TIMEOUT_S:10}
    write_timeout_s: ${HTTP_WRITE_TIMEOUT_S:20}
    idle_timeout_s: ${HTTP_IDLE_TIMEOUT_S:60}
    workers: ${HTTP_WORKERS:1}
    cors:
      enabled: ${HTTP_CORS_ENABLED:false}
      origins: ${HTTP_CORS_ORIGINS:*}
  # Background scheduler tick, if used
  scheduler_tick_ms: ${SCHEDULER_TICK_MS:500}

security:
  # Global toggle for FIPS-like operations (where applicable)
  fips_like: ${SEC_FIPS:false}
  # CSP/header hardening for embedded admin UI (if any)
  headers_hardening: ${SEC_HEADERS_HARDENING:true}
  # Minimum required TLS for outbound clients (documentational for quickstart)
  min_tls: TLS1_2
  # JWT auth for API
  auth:
    jwt_issuer: ${AUTH_JWT_ISSUER:ledger-core}
    jwt_audience: ${AUTH_JWT_AUD:ledger-api}
    jwt_public_keys_jwks_url: ${AUTH_JWKS_URL:}     # optional: OIDC JWKS
    jwt_hs256_secret: ${AUTH_JWT_HS256_SECRET:}     # optional for HS256 only
    access_token_ttl_s: ${AUTH_ACCESS_TTL_S:900}
    refresh_token_ttl_s: ${AUTH_REFRESH_TTL_S:2592000}
  # CSRF settings for session-based UI
  csrf:
    enabled: ${CSRF_ENABLED:false}
    cookie_name: ${CSRF_COOKIE_NAME:csrf-token}
  # IP allow/deny lists
  network:
    allow_cidrs: ${NET_ALLOW_CIDRS:}   # comma-separated, empty means allow all
    deny_cidrs: ${NET_DENY_CIDRS:}

database:
  # Async Postgres DSN (SQLAlchemy asyncpg)
  dsn: ${DB_DSN:postgresql+asyncpg://ledger:ledger@localhost:5432/ledger}
  pool:
    min_size: ${DB_POOL_MIN:5}
    max_size: ${DB_POOL_MAX:30}
    max_queries: ${DB_POOL_MAX_QUERIES:50000}
    max_inactive_connection_lifetime_s: ${DB_POOL_IDLE_S:300}
  timeouts:
    connect_timeout_s: ${DB_CONNECT_TIMEOUT_S:5}
    command_timeout_s: ${DB_COMMAND_TIMEOUT_S:30}
    statement_timeout_s: ${DB_STATEMENT_TIMEOUT_S:60}
  migrations:
    auto_run: ${DB_MIGRATE_AUTO:true}   # alembic on startup
    script_location: ${DB_MIGRATE_PATH:./migrations}

cache:
  redis_url: ${REDIS_URL:redis://localhost:6379/0}
  pool_max_connections: ${REDIS_POOL_MAX:100}
  socket_timeout_s: ${REDIS_SOCKET_TIMEOUT_S:2}
  tls_enabled: ${REDIS_TLS:false}

broker:
  # Choose: redis|rabbitmq|sqs|kafka (driver selection at runtime)
  driver: ${BROKER_DRIVER:redis}
  redis_stream:
    stream: ${BROKER_REDIS_STREAM:ledger-queue}
    consumer_group: ${BROKER_REDIS_GROUP:finalizers}
    maxlen: ${BROKER_REDIS_MAXLEN:100000}
    claim_idle_ms: ${BROKER_REDIS_CLAIM_IDLE_MS:60000}
  rabbitmq:
    url: ${RABBITMQ_URL:amqp://guest:guest@localhost:5672/}
    queue: ${RABBITMQ_QUEUE:ledger.finalize}
    prefetch: ${RABBITMQ_PREFETCH:64}
    dlq: ${RABBITMQ_DLQ:ledger.finalize.dlq}
  sqs:
    queue_url: ${SQS_QUEUE_URL:}
    dlq_url: ${SQS_DLQ_URL:}
    visibility_timeout_s: ${SQS_VIS_TIMEOUT_S:60}
  kafka:
    bootstrap_servers: ${KAFKA_BOOTSTRAP:localhost:9092}
    topic: ${KAFKA_TOPIC:ledger.finalize}
    acks: ${KAFKA_ACKS:all}

storage:
  # Optional object storage for large payloads/exports
  backend: ${STORAGE_BACKEND:fs}  # fs|s3|gcs
  fs:
    base_path: ${STORAGE_FS_PATH:./var/objects}
  s3:
    bucket: ${S3_BUCKET:}
    endpoint: ${S3_ENDPOINT:}
    region: ${S3_REGION:}
    access_key: ${S3_ACCESS_KEY:}
    secret_key: ${S3_SECRET_KEY:}
    sse: ${S3_SSE:AES256}
  gcs:
    bucket: ${GCS_BUCKET:}
    credentials_file: ${GCS_CREDENTIALS:}

kms:
  # Plug-in KMS adapter; for GCP use ledger.adapters.kms.gcp_kms.GCPKMSAdapter
  provider: ${KMS_PROVIDER:gcp}    # gcp|aws|vault|local
  gcp:
    project: ${GCP_KMS_PROJECT:}
    location: ${GCP_KMS_LOCATION:global}
    key_ring: ${GCP_KMS_KEY_RING:ledger-core}
    key: ${GCP_KMS_KEY:symmetric-aead}
    key_version: ${GCP_KMS_KEY_VERSION:}  # for asymmetric ops
    request_timeout_s: ${GCP_KMS_REQUEST_TIMEOUT_S:15}
    overall_timeout_s: ${GCP_KMS_OVERALL_TIMEOUT_S:60}
    max_retries: ${GCP_KMS_MAX_RETRIES:5}
    initial_backoff_s: ${GCP_KMS_INITIAL_BACKOFF_S:0.2}
    max_backoff_s: ${GCP_KMS_MAX_BACKOFF_S:5.0}
    aead_tag_bytes: ${GCP_KMS_AEAD_TAG_BYTES:16}
  # Local dev-only fallback (not for production)
  local_dev:
    secret_hex: ${LOCAL_KMS_SECRET_HEX:}  # 64 hex chars

auditor:
  # Matches ledger/security/auditor.py
  sink: ${AUDIT_SINK:file}        # file|sqlite
  hmac_secret_b64: ${AUDIT_HMAC_B64:}    # optional HMAC over chain hash
  include_prev_mac: ${AUDIT_INCLUDE_PREV_MAC:true}
  file:
    dir: ${AUDIT_DIR:./audit-logs}
    prefix: ${AUDIT_PREFIX:audit}
    rotate_daily: ${AUDIT_ROTATE_DAILY:true}
    rotate_max_bytes: ${AUDIT_ROTATE_MAX:134217728}  # 128MB
    retention_days: ${AUDIT_RETENTION_DAYS:90}
  sqlite:
    path: ${AUDIT_SQLITE_PATH:./audit-logs/audit.sqlite}
  truncate_meta_at: ${AUDIT_TRUNCATE_META:10000}

workers:
  # Finalize worker settings (ledger/workers/finalize_worker.py)
  finalize:
    enabled: ${WORKER_FINALIZE_ENABLED:true}
    concurrency: ${WORKER_FINALIZE_CONCURRENCY:8}
    poll_interval_s: ${WORKER_FINALIZE_POLL_S:0.5}
    visibility_timeout_s: ${WORKER_FINALIZE_VIS_S:60}
    max_messages_per_poll: ${WORKER_FINALIZE_BATCH:16}
    max_retries: ${WORKER_FINALIZE_MAX_RETRIES:8}
    initial_backoff_s: ${WORKER_FINALIZE_BACKOFF_S:0.5}
    max_backoff_s: ${WORKER_FINALIZE_BACKOFF_MAX_S:20}
    mode: ${WORKER_FINALIZE_MODE:STRICT}   # STRICT|LENIENT
    signer_key_version: ${WORKER_FINALIZE_SIGNER_VER:}
    commitment_salt: ${WORKER_FINALIZE_SALT:}  # optional, strengthens commitment uniqueness
  # Optional ingestion worker (placeholder)
  ingestion:
    enabled: ${WORKER_INGESTION_ENABLED:false}
    concurrency: ${WORKER_INGESTION_CONCURRENCY:4}

api:
  enable_docs: ${API_DOCS:true}
  rate_limits:
    # Token bucket limits per identity
    per_ip_rps: ${API_RATE_IP_RPS:10}
    per_ip_burst: ${API_RATE_IP_BURST:40}
    per_user_rps: ${API_RATE_USER_RPS:20}
    per_user_burst: ${API_RATE_USER_BURST:80}
  payload_limits:
    max_json_kb: ${API_MAX_JSON_KB:512}
    max_upload_mb: ${API_MAX_UPLOAD_MB:10}

features:
  # Feature flags to gate risky operations
  allow_negative_balances: ${FEAT_NEG_BAL:false}
  enable_merkle_commitments: ${FEAT_MERKLE:true}
  enable_envelope_encryption: ${FEAT_ENVELOPE:true}
  strict_schema_validation: ${FEAT_STRICT_SCHEMA:true}

observability:
  logging:
    level: ${LOG_LEVEL:INFO}     # DEBUG|INFO|WARNING|ERROR
    json: ${LOG_JSON:true}
    include_trace_ids: ${LOG_TRACE_IDS:true}
  metrics:
    prometheus_enabled: ${METRICS_PROM_ENABLED:true}
    bind: ${METRICS_BIND:0.0.0.0:9100}
  tracing:
    otlp_enabled: ${TRACING_OTLP:true}
    otlp_endpoint: ${OTLP_ENDPOINT:http://localhost:4317}
    service_name: ${OTLP_SERVICE_NAME:ledger-core}
    sample_ratio: ${OTLP_SAMPLE_RATIO:0.1}

webhooks:
  # Outbound notifications after finalization
  enabled: ${WEBHOOKS_ENABLED:false}
  endpoints:
    - name: ${WH_1_NAME:}
      url: ${WH_1_URL:}
      secret: ${WH_1_SECRET:}
      timeout_s: ${WH_1_TIMEOUT_S:5}
      retry_max: ${WH_1_RETRY_MAX:5}

policies:
  # Data retention by domain object (days)
  retention_days:
    audit_events: ${RETENTION_AUDIT_DAYS:90}
    transactions: ${RETENTION_TX_DAYS:365}
    sessions: ${RETENTION_SESS_DAYS:7}
  # KMS rotation and key usage policies (documentary constraints validated by ops)
  kms:
    symmetric_rotate_days: ${POL_KMS_SYM_ROTATE:90}
    asymmetric_rotate_days: ${POL_KMS_ASYM_ROTATE:180}
    forbid_plaintext_keys: ${POL_FORBID_PLAINTEXT_KEYS:true}

validation:
  # Startup health checks
  require_db: ${VALIDATE_DB:true}
  require_cache: ${VALIDATE_CACHE:true}
  require_broker: ${VALIDATE_BROKER:true}
  require_kms: ${VALIDATE_KMS:false}  # allow local dev without KMS

testing:
  # Deterministic behavior toggles for tests
  freeze_time_iso: ${TEST_FREEZE_TIME:}
  seed_random: ${TEST_SEED:}

# End of file
