# red-vs-blue-engine/agents/red_team/exploit_agent.py

import asyncio
import logging
from typing import List, Optional

from core.models.targets import TargetProfile
from core.models.exploit import ExploitResult
from core.ai.exploit_strategy import ExploitPlanner
from core.security.sandbox import AgentExecutionSandbox
from core.policy.rbac import enforce_exploit_policy
from core.telemetry.event_bus import EventBus
from core.utils.tracing import trace_execution
from core.security.zkp import attach_proof

logger = logging.getLogger("red.exploit_agent")


class ExploitAgent:
    """
    Промышленный AI-агент Red Team, отвечающий за автономную фазу Exploit в рамках атаки.
    Поддерживает AI-планирование, RBAC, ZKP, sandbox-исполнение и телеметрию.
    """

    def __init__(
        self,
        agent_id: str,
        planner: ExploitPlanner,
        sandbox: AgentExecutionSandbox,
        event_bus: EventBus,
    ):
        self.agent_id = agent_id
        self.planner = planner
        self.sandbox = sandbox
        self.event_bus = event_bus

    @trace_execution
    async def execute(self, targets: List[TargetProfile]) -> List[ExploitResult]:
        logger.info(f"[{self.agent_id}] Запуск фазы Exploit против {len(targets)} целей")

        valid_targets = [t for t in targets if await self._is_target_allowed(t)]
        results = []

        for target in valid_targets:
            async with self.sandbox.isolated(agent_id=self.agent_id, target_id=target.id):
                exploit = await self.planner.plan(target)
                if not exploit:
                    logger.warning(f"[{self.agent_id}] Нет стратегии для цели {target.id}")
                    continue

                result = await self._run_exploit(target, exploit)
                if result:
                    results.append(result)
                    await self._emit_event(result)

        return results

    async def _is_target_allowed(self, target: TargetProfile) -> bool:
        permitted = enforce_exploit_policy(self.agent_id, target)
        if not permitted:
            logger.warning(f"[{self.agent_id}] Доступ к цели {target.id} запрещён RBAC")
        return permitted

    async def _run_exploit(self, target: TargetProfile, exploit) -> Optional[ExploitResult]:
        try:
            logger.debug(f"[{self.agent_id}] Исполнение атаки против {target.id}")
            output = await exploit.run()

            result = ExploitResult(
                agent_id=self.agent_id,
                target_id=target.id,
                success=output.success,
                evidence=output.evidence,
                impact_score=output.impact,
                zkp=attach_proof(self.agent_id, target.id, output)
            )
            logger.info(f"[{self.agent_id}] Атака против {target.id} завершена: {'успех' if output.success else 'неудача'}")
            return result

        except Exception as e:
            logger.exception(f"[{self.agent_id}] Ошибка при атаке на {target.id}: {e}")
            return None

    async def _emit_event(self, result: ExploitResult):
        await self.event_bus.publish("red.exploit.executed", result.dict())

