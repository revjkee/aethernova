import subprocess
import logging
import json
from typing import Dict, Optional, Literal, Union, List
from datetime import datetime
from pydantic import BaseModel, Field, validator
from enum import Enum

logger = logging.getLogger("blackvault.handlers.patch_vulnerability")

# --- SUPPORTED TARGET TYPES ---

class PatchEngine(str, Enum):
    APT = "apt"
    YUM = "yum"
    PIP = "pip"
    DOCKER = "docker"
    KUBERNETES = "kubernetes"

class PatchMode(str, Enum):
    AUTO = "auto"
    VERIFY_ONLY = "verify_only"
    DRY_RUN = "dry_run"

# --- REQUEST MODEL ---

class PatchRequest(BaseModel):
    cve_id: str = Field(..., regex=r"^CVE-\d{4}-\d{4,}$")
    engine: PatchEngine
    target: str  # e.g., package name, docker image, k8s deployment
    mode: PatchMode = PatchMode.AUTO
    operator: str = Field(..., min_length=3)
    context: Optional[str] = None
    token: Optional[str] = None  # if needed for API or private repo access

    @validator("target")
    def validate_target(cls, v):
        if len(v.strip()) < 2:
            raise ValueError("Invalid target specified")
        return v.strip()


# --- RESULT MODEL ---

class PatchResult(BaseModel):
    success: bool
    message: str
    timestamp: datetime
    cve_id: str
    operator: str
    engine: PatchEngine
    target: str
    mode: PatchMode
    dry_run: bool
    cmd: Optional[List[str]] = None
    details: Optional[Dict] = None


# --- PATCH EXECUTION WRAPPER ---

class PatchManager:
    def __init__(self, req: PatchRequest):
        self.req = req
        self.cmd: List[str] = []
        self.result: Optional[PatchResult] = None

    def _generate_cmd(self):
        target = self.req.target
        if self.req.engine == PatchEngine.APT:
            self.cmd = ["apt-get", "install", "--only-upgrade", "-y", target]
        elif self.req.engine == PatchEngine.YUM:
            self.cmd = ["yum", "update", "-y", target]
        elif self.req.engine == PatchEngine.PIP:
            self.cmd = ["pip", "install", "--upgrade", target]
        elif self.req.engine == PatchEngine.DOCKER:
            self.cmd = ["docker", "pull", target]
        elif self.req.engine == PatchEngine.KUBERNETES:
            self.cmd = [
                "kubectl", "set", "image", f"deployment/{target}",
                f"{target}={target}:latest"
            ]
        else:
            raise ValueError("Unsupported patch engine")

    def _validate_patch_source(self):
        # Example of CVE registry check (stubbed, normally connects to NVD/VulnDB)
        logger.debug(f"Validating CVE: {self.req.cve_id} for target {self.req.target}")
        if not self.req.cve_id.startswith("CVE-"):
            raise ValueError("Invalid CVE format")

    def execute(self) -> PatchResult:
        logger.info(f"Patch request received: {self.req.dict()}")
        self._validate_patch_source()
        self._generate_cmd()

        if self.req.mode == PatchMode.DRY_RUN or self.req.mode == PatchMode.VERIFY_ONLY:
            return PatchResult(
                success=True,
                message="Dry-run / Verify only mode â€” no patch applied",
                timestamp=datetime.utcnow(),
                cve_id=self.req.cve_id,
                operator=self.req.operator,
                engine=self.req.engine,
                target=self.req.target,
                mode=self.req.mode,
                dry_run=True,
                cmd=self.cmd,
                details={"note": "command simulated"}
            )

        try:
            result = subprocess.run(self.cmd, check=True, capture_output=True, text=True)
            logger.info(f"Patch command executed: {self.cmd}")
            return PatchResult(
                success=True,
                message="Patch applied successfully",
                timestamp=datetime.utcnow(),
                cve_id=self.req.cve_id,
                operator=self.req.operator,
                engine=self.req.engine,
                target=self.req.target,
                mode=self.req.mode,
                dry_run=False,
                cmd=self.cmd,
                details={
                    "stdout": result.stdout.strip(),
                    "stderr": result.stderr.strip()
                }
            )
        except subprocess.CalledProcessError as e:
            logger.error(f"Patch failed: {e}")
            return PatchResult(
                success=False,
                message="Patch command failed",
                timestamp=datetime.utcnow(),
                cve_id=self.req.cve_id,
                operator=self.req.operator,
                engine=self.req.engine,
                target=self.req.target,
                mode=self.req.mode,
                dry_run=False,
                cmd=self.cmd,
                details={
                    "error": str(e),
                    "stdout": e.stdout,
                    "stderr": e.stderr
                }
            )


# --- MAIN HANDLER FUNCTION ---

def patch_vulnerability(request_data: Dict[str, Union[str, Dict]]) -> Dict:
    try:
        req = PatchRequest(**request_data)
        patcher = PatchManager(req)
        result = patcher.execute()

        audit_log = {
            "event": "vulnerability_patch_attempt",
            "result": result.dict(),
            "context": req.context or "global",
            "logged_at": datetime.utcnow().isoformat()
        }
        logger.info(json.dumps(audit_log, indent=2))
        return result.dict()
    except Exception as ex:
        logger.exception(f"Unhandled patching exception: {ex}")
        return {
            "success": False,
            "message": "Unhandled exception during patching",
            "error": str(ex),
            "timestamp": datetime.utcnow().isoformat()
        }
