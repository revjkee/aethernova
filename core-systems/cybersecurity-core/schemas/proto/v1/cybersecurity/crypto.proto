syntax = "proto3";

package aethernova.cybersecurity.v1;

option go_package        = "github.com/aethernova/cybersecurity-core/gen/proto/v1/cybersecurity;cybersecurity";
option java_package      = "org.aethernova.cybersecurity.v1";
option java_outer_classname = "CryptoProto";
option csharp_namespace  = "Aethernova.Cybersecurity.V1";
option php_namespace     = "Aethernova\\Cybersecurity\\V1";
option ruby_package      = "Aethernova::Cybersecurity::V1";
option objc_class_prefix = "ANCY";
option optimize_for      = SPEED;

import "google/protobuf/any.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

// ===============================
// ===== Common Enumerations =====
// ===============================

enum KeyPurpose {
  KEY_PURPOSE_UNSPECIFIED = 0;
  ENCRYPT_DECRYPT         = 1;
  SIGN_VERIFY             = 2;
  MAC                     = 3;
  DERIVE                  = 4;
  WRAP_UNWRAP             = 5;
  CERT_SIGN               = 6;  // CA/ICA issuing
}

enum KeyState {
  KEY_STATE_UNSPECIFIED     = 0;
  ENABLED                   = 1;
  DISABLED                  = 2;
  SCHEDULED_FOR_DESTRUCTION = 3;
  DESTROYED                 = 4;
}

enum ProtectionLevel {
  PROTECTION_LEVEL_UNSPECIFIED = 0;
  SOFTWARE                     = 1;  // софт-хранилище
  HSM                          = 2;  // аппаратный модуль (on-prem/CloudHSM)
  TEE                          = 3;  // доверенная среда (SGX/TDX/SEV)
  CLOUD_KMS                    = 4;  // внешний KMS (URI)
  NITRO_ENCLAVE                = 5;  // AWS Nitro Enclaves
}

enum KeyType {
  KEY_TYPE_UNSPECIFIED = 0;
  SYMMETRIC            = 1;
  ASYMMETRIC_RSA       = 2;
  ASYMMETRIC_EC        = 3;   // P-256/P-384/P-521/secp256k1
  ASYMMETRIC_ED        = 4;   // Ed25519/Ed448
  ASYMMETRIC_PQC       = 5;   // PQC (e.g., Dilithium)
  HYBRID               = 6;   // классика + PQC
}

// Hash family
enum HashAlgorithm {
  HASH_ALGORITHM_UNSPECIFIED = 0;
  SHA256                     = 1;
  SHA384                     = 2;
  SHA512                     = 3;
  SHA3_256                   = 4;
  SHA3_512                   = 5;
  BLAKE2B_256                = 6;
  BLAKE2B_512                = 7;
}

// AEAD family
enum AeadAlgorithm {
  AEAD_ALGORITHM_UNSPECIFIED = 0;
  AES_GCM_128                = 1;
  AES_GCM_256                = 2;
  CHACHA20_POLY1305          = 3;
  XCHACHA20_POLY1305         = 4;
}

// Signature family
enum SignatureAlgorithm {
  SIGNATURE_ALGORITHM_UNSPECIFIED = 0;
  // RSA-PSS
  RSA_PSS_SHA256                  = 1;
  RSA_PSS_SHA384                  = 2;
  RSA_PSS_SHA512                  = 3;
  // ECDSA
  ECDSA_P256_SHA256               = 10;
  ECDSA_P384_SHA384               = 11;
  ECDSA_P521_SHA512               = 12;
  // Edwards
  ED25519                         = 20;
  ED448                           = 21;
  // PQC (signatures)
  DILITHIUM2                      = 30;
  DILITHIUM3                      = 31;
  DILITHIUM5                      = 32;
  // Hybrid examples (metadata-driven)
  HYBRID_RSA_PSS_SHA256_DILITHIUM2 = 40;
}

// MAC family
enum MacAlgorithm {
  MAC_ALGORITHM_UNSPECIFIED = 0;
  HMAC_SHA256               = 1;
  HMAC_SHA384               = 2;
  HMAC_SHA512               = 3;
}

// KDF family
enum KdfAlgorithm {
  KDF_ALGORITHM_UNSPECIFIED = 0;
  HKDF_SHA256                = 1;
  HKDF_SHA384                = 2;
  HKDF_SHA512                = 3;
  PBKDF2_SHA256              = 10;
  SCRYPT                     = 20;
  ARGON2ID                   = 30; // параметры в KdfParams
}

// Curve identifiers for EC/Ed
enum EcCurve {
  EC_CURVE_UNSPECIFIED = 0;
  P256                 = 1;
  P384                 = 2;
  P521                 = 3;
  SECP256K1            = 4;
  ED25519_CURVE        = 10; // logical placeholder
  ED448_CURVE          = 11;
}

// ===============================
// ===== Spec & Key Metadata =====
// ===============================

message Labels {
  map<string, string> items = 1;
}

message KeySpec {
  KeyType         key_type         = 1;
  KeyPurpose      purpose          = 2;
  ProtectionLevel protection_level = 3;

  // Unified algorithm descriptor
  CryptoAlgorithm algorithm = 4;

  // Size/curve as applicable
  uint32 key_size_bits = 10;  // RSA/AES/… (e.g., 2048, 3072, 4096; 128/256)
  EcCurve curve        = 11;  // for EC/Ed

  // PQC/hybrid knobs
  bool   hybrid_enabled = 20;
  string pqc_variant    = 21; // e.g., "dilithium2", for forward compatibility

  // Rotation & retention
  RotationPolicy rotation_policy = 30;

  // External KMS/HSM binding
  string kms_uri = 40; // e.g., "aws-kms://arn:aws:kms:.../key/..."
  Labels labels  = 41;
}

message RotationPolicy {
  bool   auto_rotate         = 1;
  google.protobuf.Duration rotation_period = 2;
  google.protobuf.Timestamp next_rotation  = 3;
  uint32 max_versions_retained             = 4;
}

message CryptoAlgorithm {
  oneof kind {
    AeadAlgorithm       aead       = 1;
    SignatureAlgorithm  signature  = 2;
    MacAlgorithm        mac        = 3;
    HashAlgorithm       hash       = 4;
    KdfAlgorithm        kdf        = 5;
  }
}

// Immutable public view
message PublicKey {
  string key_id           = 1;
  string key_version_id   = 2;
  KeyType key_type        = 3;
  KeyPurpose purpose      = 4;
  CryptoAlgorithm algorithm = 5;

  // Encodings
  bytes  spki_der = 10;            // SubjectPublicKeyInfo (DER)
  string pem      = 11;            // PEM public key
  Jwk    jwk      = 12;            // JWK
  bytes  fingerprint_sha256 = 13;  // SPKI SHA-256
}

// JWKS/JWK minimal public subset
message Jwk {
  string kid = 1;
  string kty = 2;   // "RSA","EC","OKP"
  string crv = 3;   // for EC/OKP
  string alg = 4;   // e.g., "RS256","ES256","EdDSA"
  string use = 5;   // "sig"|"enc"
  // RSA
  string n = 10; // base64url
  string e = 11;
  // EC/OKP
  string x = 20;
  string y = 21; // EC only
}

message KeyVersion {
  string key_version_id   = 1;
  KeyState state          = 2;
  google.protobuf.Timestamp create_time = 3;
  google.protobuf.Timestamp destroy_time = 4;
}

message Key {
  string    key_id         = 1;
  KeySpec   spec           = 2;
  KeyState  state          = 3;
  repeated KeyVersion versions = 4;
  google.protobuf.Timestamp create_time = 5;
  google.protobuf.Timestamp update_time = 6;

  // Public projection
  PublicKey public_key = 10;
}

// ===============================
// ===== Request/Response DTO =====
// ===============================

message GenerateKeyRequest {
  KeySpec spec = 1;
  // Optional deterministic import (e.g., for testing) — discouraged in prod.
  google.protobuf.BytesValue client_side_seed = 10;
  // Idempotency key for safe retries
  string request_id = 90;
}
message ImportKeyRequest {
  KeySpec spec = 1;
  oneof material {
    // Wrapped key material (KEK identified below)
    WrappedKey wrapped = 10;
    // Direct symmetric key bytes (SOFTWARE only; restricted)
    bytes raw_symmetric_key = 11;
    // Private key in PKCS#8 (DER/PEM) — SOFTWARE/TEE only
    PrivateKeyContainer private_key = 12;
  }
  string request_id = 90;
}
message PrivateKeyContainer {
  bytes der = 1;      // PKCS#8 DER
  string pem = 2;     // PKCS#8 PEM
  // Optional passphrase for legacy encodings (PEM)
  google.protobuf.StringValue passphrase = 3;
}
message WrappedKey {
  // Algorithm used to wrap (AES-KWP, AES-GCM, RSA-OAEP, etc.)
  string wrapping_alg = 1;
  // Identifier/URI of KEK (Key Encryption Key)
  string kek_id = 2;
  bytes  iv_or_nonce = 3;
  bytes  tag         = 4;  // AEAD tag if applicable
  bytes  wrapped_key = 5;
  bytes  aad         = 6;  // optional
}

message GetKeyRequest {
  string key_id = 1;
}
message ListKeysRequest {
  uint32 page_size = 1;
  string page_token = 2;
  // Optional filters
  KeyPurpose      purpose_filter = 3;
  ProtectionLevel protection_filter = 4;
}
message ListKeysResponse {
  repeated Key keys = 1;
  string next_page_token = 2;
}

message RotateKeyRequest {
  string key_id   = 1;
  // Optional override of rotation policy for this rotation
  google.protobuf.BoolValue enable_old_version_until_expiry = 2;
  string request_id = 90;
}
message DeactivateKeyRequest {
  string key_id = 1;
  string request_id = 90;
}
message DestroyKeyRequest {
  string key_id = 1;
  string request_id = 90;
}

message GetPublicKeyRequest {
  string key_id         = 1;
  string key_version_id = 2; // optional: specific version
}

message ExportJWKSRequest {
  repeated string key_ids = 1; // if empty — export all ENABLED public keys
}
message JWKS {
  repeated Jwk keys = 1;
}

// ----- Random / Hash / HMAC / KDF -----

message RandomBytesRequest {
  uint32 length = 1; // bytes, max reasonable cap enforced server-side
  // Optional: caller intent tracing
  string purpose = 2;
}
message RandomBytesResponse {
  bytes data = 1;
}

message HashRequest {
  HashAlgorithm algorithm = 1;
  bytes data = 2;
  bool  output_hex = 3;
}
message HashResponse {
  bytes digest = 1;
  string hex_digest = 2;
}

message HmacRequest {
  string key_id = 1;
  MacAlgorithm algorithm = 2;
  bytes data = 3;
  bytes aad  = 4; // optional contextual data
}
message HmacResponse {
  bytes tag = 1;
}

message HmacVerifyRequest {
  string key_id = 1;
  MacAlgorithm algorithm = 2;
  bytes data = 3;
  bytes tag  = 4;
  bytes aad  = 5;
}
message VerifyResponse {
  bool valid = 1;
  // Optional diagnostics (not for side-channel)
  string failure_reason = 2;
}

message KdfParams {
  // HKDF
  bytes hkdf_salt = 1;
  bytes hkdf_info = 2;
  // PBKDF2
  uint32 pbkdf2_iterations = 10;
  // scrypt
  uint32 scrypt_N = 20; // e.g., 2^15
  uint32 scrypt_r = 21;
  uint32 scrypt_p = 22;
  // Argon2id
  uint32 argon2id_memory_kib = 30;
  uint32 argon2id_iterations = 31;
  uint32 argon2id_parallelism = 32;
}

message DeriveKeyRequest {
  KdfAlgorithm algorithm = 1;
  bytes ikm = 2;                // input keying material (NOT stored)
  uint32 length = 3;            // output key length in bytes
  HashAlgorithm prf = 4;        // for HKDF/PBKDF2
  KdfParams params = 5;
}
message DeriveKeyResponse {
  bytes okm = 1;
}

// ----- Sign / Verify -----

message SignRequest {
  string key_id = 1;
  SignatureAlgorithm algorithm = 2; // if empty, use key default
  oneof payload {
    bytes data   = 10; // raw bytes to be hashed internally (recommended)
    bytes digest = 11; // precomputed digest — caller sets algorithm in field 2
  }
  bytes context_info = 20; // optional domain-separation/context
}
message SignResponse {
  bytes signature = 1;
  // For algs with R/S components, server returns DER-encoded signature.
}

message VerifyRequest {
  string key_id = 1;
  SignatureAlgorithm algorithm = 2;
  oneof payload {
    bytes data   = 10;
    bytes digest = 11;
  }
  bytes signature = 20;
  bytes context_info = 21;
}

// ----- AEAD Encrypt / Decrypt -----

message EncryptRequest {
  string key_id = 1;
  AeadAlgorithm algorithm = 2; // if empty, use key default
  bytes plaintext = 3;
  bytes aad       = 4;
  google.protobuf.BytesValue nonce = 5; // optional; if absent, server generates
}
message EncryptResponse {
  bytes ciphertext = 1;
  bytes nonce      = 2;
  bytes tag        = 3; // may be empty for algorithms embedding tag
}

message DecryptRequest {
  string key_id = 1;
  AeadAlgorithm algorithm = 2;
  bytes ciphertext = 3;
  bytes aad        = 4;
  bytes nonce      = 5;
  bytes tag        = 6;
}
message DecryptResponse {
  bytes plaintext = 1;
}

// ----- Envelope (data key per object) -----

message EnvelopeEncryptRequest {
  // KEK used to wrap freshly generated DEK
  string kek_key_id = 1;                 // WRAP_UNWRAP purpose
  AeadAlgorithm data_aead_algorithm = 2; // DEK AEAD
  bytes plaintext = 3;
  bytes aad       = 4;
}
message EnvelopeEncryptResponse {
  bytes wrapped_dek = 1;
  string wrapping_alg = 2;
  bytes iv_or_nonce = 3;
  bytes tag         = 4;
  bytes ciphertext  = 5;
  bytes aead_nonce  = 6; // DEK AEAD nonce (if applicable)
}

message EnvelopeDecryptRequest {
  string kek_key_id = 1;
  AeadAlgorithm data_aead_algorithm = 2;
  bytes wrapped_dek = 3;
  string wrapping_alg = 4;
  bytes iv_or_nonce = 5;
  bytes tag         = 6;
  bytes ciphertext  = 7;
  bytes aad         = 8;
  bytes aead_nonce  = 9;
}
message EnvelopeDecryptResponse {
  bytes plaintext = 1;
}

// ----- Wrap / Unwrap specific keys -----

message WrapKeyRequest {
  string kek_key_id = 1;
  bytes  target_key = 2;   // raw key bytes (e.g., DEK); server-side erase
  string wrapping_alg = 3; // e.g., "AES-KWP","RSA-OAEP-256","AES-GCM"
  bytes  aad = 4;
}
message WrapKeyResponse {
  WrappedKey wrapped = 1;
}

message UnwrapKeyRequest {
  WrappedKey wrapped = 1;
}
message UnwrapKeyResponse {
  bytes key = 1; // raw unwrapped key bytes (returned only to authorized callers)
}

// ===============================
// ===== X.509 / CSR / Chain =====
// ===============================

message DistinguishedName {
  string cn = 1;
  string o  = 2;
  string ou = 3;
  string c  = 4;
  string st = 5;
  string l  = 6;
  string email = 7;
}

message SubjectAltName {
  repeated string dns_names   = 1;
  repeated string emails      = 2;
  repeated string ip_addresses = 3;
  repeated string uris        = 4;
}

message CreateCsrRequest {
  // Use existing key or generate ephemeral and return as wrapped
  string key_id = 1; // optional; if empty, server may generate new key if allowed
  DistinguishedName subject = 2;
  SubjectAltName san = 3;
  SignatureAlgorithm signature_algorithm = 4; // if empty, inferred
  bool export_private_key = 5; // only if policy allows (SOFTWARE/TEE)
}
message CreateCsrResponse {
  bytes pkcs10_der = 1;
  string pem = 2;
  // If new key was generated:
  google.protobuf.StringValue key_id = 10;
  PublicKey public_key = 11;
  // Optionally return wrapped private for escrow (policy-restricted)
  WrappedKey wrapped_private = 12;
}

message Certificate {
  bytes der = 1;
  string pem = 2;
  string serial = 3;
  DistinguishedName subject = 4;
  DistinguishedName issuer  = 5;
  SubjectAltName san = 6;
  google.protobuf.Timestamp not_before = 7;
  google.protobuf.Timestamp not_after  = 8;
  bool is_ca = 9;
  bytes aki = 10; // authority key identifier
  bytes ski = 11; // subject key identifier
}

message IssueCertificateRequest {
  // CA key used for signing (CERT_SIGN)
  string ca_key_id = 1;
  bytes csr_der = 2;
  google.protobuf.Duration ttl = 3;
  bool is_ca = 4;
  // Extensions/preferences could be codified here as needed
}
message VerifyCertificateChainRequest {
  Certificate leaf = 1;
  repeated Certificate chain = 2; // intermediates
  repeated Certificate roots = 3; // trust anchors
  bool check_revocation = 4;
}
message VerifyCertificateChainResponse {
  bool valid = 1;
  string failure_reason = 2;
  repeated string verified_chain_subjects = 3; // ordered subjects
}

// ===============================
// ===== Attestation (TEE/TPM) ===
// ===============================

enum AttestationFormat {
  ATTESTATION_FORMAT_UNSPECIFIED = 0;
  TEE_SGX                         = 1;
  TEE_TDX                         = 2;
  TEE_SEV                         = 3;
  AWS_NITRO                       = 4;
  TPM_QUOTE                       = 5;
}

message AttestationEvidence {
  AttestationFormat format = 1;
  bytes evidence = 2;     // raw attestation doc/quote
  bytes nonce    = 3;
  map<string,string> claims = 4; // parsed claims if known
}

message AttestRequest {
  AttestationEvidence evidence = 1;
  // Optional policy to check expected measurements, PCRs, etc.
  google.protobuf.Any policy = 2;
}
message AttestResponse {
  bool valid = 1;
  string failure_reason = 2;
  map<string,string> verified_claims = 3;
}

message VerifyAttestationRequest {
  AttestationEvidence evidence = 1;
}
message VerifyAttestationResponse {
  bool valid = 1;
  string failure_reason = 2;
}

// ===============================
// ===== JWS / JWE convenience ===
// ===============================

message CreateJWSRequest {
  string key_id = 1;
  SignatureAlgorithm algorithm = 2;
  map<string, google.protobuf.Any> header = 3; // protected header claims
  bytes payload = 4;
  bool detached_payload = 5;
}
message CreateJWSResponse {
  string compact = 1; // compact JWS if not detached
  // For detached mode, return signature components
  bytes signature = 2;
}

message VerifyJWSRequest {
  string jws_compact = 1;
  // If detached, supply payload
  bytes detached_payload = 2;
}
message VerifyJWSResponse {
  bool valid = 1;
  string failure_reason = 2;
  map<string, google.protobuf.Any> header = 3;
  bytes payload = 4;
}

message CreateJWERequest {
  // For simplicity, single-recipient JWE using the provided key
  string key_id = 1;            // ENCRYPT_DECRYPT key
  AeadAlgorithm enc = 2;        // content encryption (AEAD)
  bytes plaintext = 3;
  bytes aad = 4;
}
message CreateJWEResponse {
  string compact = 1;           // JWE compact serialization
}

message DecryptJWERequest {
  string jwe_compact = 1;
}
message DecryptJWEResponse {
  bytes plaintext = 1;
  bytes aad       = 2;
}

// ===============================
// ===== Service Definition ======
// ===============================

service CryptoService {
  // Key lifecycle
  rpc GenerateKey (GenerateKeyRequest) returns (Key);
  rpc ImportKey   (ImportKeyRequest)   returns (Key);
  rpc GetKey      (GetKeyRequest)      returns (Key);
  rpc ListKeys    (ListKeysRequest)    returns (ListKeysResponse);
  rpc RotateKey   (RotateKeyRequest)   returns (Key);
  rpc DeactivateKey (DeactivateKeyRequest) returns (Key);
  rpc DestroyKey  (DestroyKeyRequest)  returns (google.protobuf.Empty);
  rpc GetPublicKey (GetPublicKeyRequest) returns (PublicKey);
  rpc ExportJWKS  (ExportJWKSRequest)  returns (JWKS);

  // Primitives
  rpc GetRandomBytes (RandomBytesRequest) returns (RandomBytesResponse);
  rpc Hash           (HashRequest)        returns (HashResponse);
  rpc CreateHMAC     (HmacRequest)        returns (HmacResponse);
  rpc VerifyHMAC     (HmacVerifyRequest)  returns (VerifyResponse);
  rpc DeriveKey      (DeriveKeyRequest)   returns (DeriveKeyResponse);

  // Signatures
  rpc Sign   (SignRequest)   returns (SignResponse);
  rpc Verify (VerifyRequest) returns (VerifyResponse);

  // AEAD
  rpc Encrypt (EncryptRequest) returns (EncryptResponse);
  rpc Decrypt (DecryptRequest) returns (DecryptResponse);

  // Envelope encryption
  rpc EnvelopeEncrypt (EnvelopeEncryptRequest) returns (EnvelopeEncryptResponse);
  rpc EnvelopeDecrypt (EnvelopeDecryptRequest) returns (EnvelopeDecryptResponse);

  // Wrapping
  rpc WrapKey   (WrapKeyRequest)   returns (WrapKeyResponse);
  rpc UnwrapKey (UnwrapKeyRequest) returns (UnwrapKeyResponse);

  // PKI
  rpc CreateCSR               (CreateCsrRequest)               returns (CreateCsrResponse);
  rpc IssueCertificate        (IssueCertificateRequest)        returns (Certificate);
  rpc VerifyCertificateChain  (VerifyCertificateChainRequest)  returns (VerifyCertificateChainResponse);

  // Attestation
  rpc Attest            (AttestRequest)            returns (AttestResponse);
  rpc VerifyAttestation (VerifyAttestationRequest) returns (VerifyAttestationResponse);

  // JWS/JWE convenience
  rpc CreateJWS  (CreateJWSRequest)  returns (CreateJWSResponse);
  rpc VerifyJWS  (VerifyJWSRequest)  returns (VerifyJWSResponse);
  rpc CreateJWE  (CreateJWERequest)  returns (CreateJWEResponse);
  rpc DecryptJWE (DecryptJWERequest) returns (DecryptJWEResponse);
}
