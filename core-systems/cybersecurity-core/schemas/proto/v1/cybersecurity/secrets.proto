// cybersecurity-core/schemas/proto/v1/cybersecurity/secrets.proto
syntax = "proto3";

package cybersecurity.v1;

option go_package        = "github.com/your-org/cybersecurity-core/gen/proto/cybersecurity/v1;cybersecurityv1";
option java_multiple_files = true;
option java_package      = "io.aethernova.cybersecurity.v1";
option csharp_namespace  = "Aethernova.Cybersecurity.V1";
option php_namespace     = "Aethernova\\Cybersecurity\\V1";
option ruby_package      = "Aethernova::Cybersecurity::V1";
option objc_class_prefix = "CSC";

// External well-known types and API annotations.
import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/field_mask.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/empty.proto";
import "google/api/annotations.proto";
import "google/api/resource.proto";
import "google/api/field_behavior.proto";

// ---------------------------
// Resource model & enums
// ---------------------------

enum SecretState {
  SECRET_STATE_UNSPECIFIED = 0;
  SECRET_ACTIVE            = 1;
  SECRET_DISABLED          = 2;
  SECRET_SCHEDULED_DESTRUCTION = 3;
}

enum SecretVersionState {
  SECRET_VERSION_STATE_UNSPECIFIED = 0;
  SECRET_VERSION_ENABLED           = 1;
  SECRET_VERSION_DISABLED          = 2;
  SECRET_VERSION_DESTROYED         = 3;
  SECRET_VERSION_SCHEDULED_DESTRUCTION = 4;
  SECRET_VERSION_COMPROMISED       = 5;
}

enum EncryptionAlgorithm {
  ENCRYPTION_ALGORITHM_UNSPECIFIED = 0;
  AES256_GCM                       = 1;
  CHACHA20_POLY1305                = 2;
  RSA_OAEP_AES_GCM                 = 3; // envelope: wrapped DEK via RSA-OAEP, payload via AES-GCM
  SM4_GCM                          = 4; // опционально для compliance-сценариев
}

enum Compression {
  COMPRESSION_UNSPECIFIED = 0;
  COMPRESSION_NONE        = 1;
  COMPRESSION_GZIP        = 2;
  COMPRESSION_ZSTD        = 3;
}

enum KmsProvider {
  KMS_PROVIDER_UNSPECIFIED = 0;
  KMS_GCP_CLOUDKMS         = 1;
  KMS_AWS_KMS              = 2;
  KMS_AZURE_KEYVAULT       = 3;
  KMS_VAULT_TRANSIT        = 4;
  KMS_LOCAL_HSM            = 5;
  KMS_OTHER                = 10;
}

enum Role {
  ROLE_UNSPECIFIED = 0;
  ROLE_READER      = 1; // доступ к версиям (plaintext по политике)
  ROLE_WRITER      = 2; // создание новых версий
  ROLE_OWNER       = 3; // управление секретом/политикой
  ROLE_ROTATOR     = 4; // ротация по расписанию
}

enum AuditAction {
  AUDIT_ACTION_UNSPECIFIED = 0;
  AUDIT_CREATE_SECRET      = 1;
  AUDIT_UPDATE_SECRET      = 2;
  AUDIT_DELETE_SECRET      = 3;
  AUDIT_DISABLE_SECRET     = 4;
  AUDIT_ENABLE_SECRET      = 5;
  AUDIT_CREATE_VERSION     = 6;
  AUDIT_DISABLE_VERSION    = 7;
  AUDIT_ENABLE_VERSION     = 8;
  AUDIT_DESTROY_VERSION    = 9;
  AUDIT_ACCESS_VERSION     = 10;
  AUDIT_SET_POLICY         = 11;
}

enum DenyReason {
  DENY_REASON_UNSPECIFIED = 0;
  DENY_NOT_FOUND          = 1;
  DENY_POLICY_VIOLATION   = 2;
  DENY_MFA_REQUIRED       = 3;
  DENY_IP_RESTRICTED      = 4;
  DENY_TIME_RESTRICTED    = 5;
  DENY_ETAG_MISMATCH      = 6;
  DENY_STATE_RESTRICTED   = 7;
}

// ---------------------------
// Core resources
// ---------------------------

// Secret describes metadata & policy. Payloads live in SecretVersion.
message Secret {
  option (google.api.resource) = {
    type: "cybersecurity.aethernova.com/Secret"
    pattern: "projects/{project}/locations/{location}/secrets/{secret}"
  };

  // Resource name: projects/{project}/locations/{location}/secrets/{secret}
  string name = 1 [(google.api.field_behavior) = IDENTIFIER];

  // Server-generated immutable UID.
  string uid  = 2  [(google.api.field_behavior) = OUTPUT_ONLY];

  SecretState state = 3;

  // Optimistic concurrency control.
  string etag = 4;

  // Free-form labels for routing/ACLs.
  map<string, string> labels = 5;

  // Arbitrary metadata (structured).
  google.protobuf.Struct annotations = 6;

  // KMS & envelope defaults applied to new versions (overridable per version).
  KmsKeyRef default_kms = 7;
  EncryptionAlgorithm default_encryption = 8;

  // Rotation & retention policies.
  RotationPolicy rotation = 9;
  ReplicationPolicy replication = 10;

  // Access policy embedded (optional; may also be managed externally).
  AccessPolicy policy = 11;

  // Statistics.
  int32 version_count = 12 [(google.api.field_behavior) = OUTPUT_ONLY];
  string latest_version = 13 [(google.api.field_behavior) = OUTPUT_ONLY]; // resource name of the latest version

  google.protobuf.Timestamp create_time = 14 [(google.api.field_behavior) = OUTPUT_ONLY];
  google.protobuf.Timestamp update_time = 15 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Reserved for future breaking-safe expansion.
  reserved 16, 17, 18;
}

// SecretVersion holds encrypted payload + crypto envelope.
message SecretVersion {
  option (google.api.resource) = {
    type: "cybersecurity.aethernova.com/SecretVersion"
    pattern: "projects/{project}/locations/{location}/secrets/{secret}/versions/{version}"
  };

  // Resource name: projects/{project}/locations/{location}/secrets/{secret}/versions/{version}
  string name = 1 [(google.api.field_behavior) = IDENTIFIER];

  SecretVersionState state = 2;

  // Integrity info (checksum of plaintext before encryption).
  Digest plaintext_checksum = 3 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Envelope metadata to decrypt payload at rest.
  EncryptionEnvelope envelope = 4;

  // Size of plaintext (bytes).
  int64 plaintext_size = 5 [(google.api.field_behavior) = OUTPUT_ONLY];

  // MIME type (e.g., application/json, text/plain).
  string content_type = 6;

  // Optional user metadata for the version.
  map<string, string> labels = 7;

  string etag = 8;

  google.protobuf.Timestamp create_time  = 9  [(google.api.field_behavior) = OUTPUT_ONLY];
  google.protobuf.Timestamp update_time  = 10 [(google.api.field_behavior) = OUTPUT_ONLY];
  google.protobuf.Timestamp destroy_time = 11 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Reserved fields for future crypto metadata/extensions.
  reserved 12, 13, 14, 15;
}

// Crypto envelope (algorithm + KMS reference + AAD).
message EncryptionEnvelope {
  EncryptionAlgorithm algorithm = 1;
  KmsKeyRef kms_key = 2;

  // AAD for AEAD modes (e.g., AES-GCM).
  bytes aad = 3;

  // IV/nonce and auth tag (for AEAD).
  bytes iv  = 4;
  bytes tag = 5;

  // Encrypted Data Encryption Key (wrapped DEK) if using envelope encryption.
  bytes wrapped_dek = 6;

  // Optional key identifier/version from KMS.
  string key_id = 7;
  string key_version = 8;
}

// Reference to a KMS key in any provider.
message KmsKeyRef {
  KmsProvider provider = 1;
  // Provider-specific URI or resource ID (e.g., gcp: //cloudkms.googleapis.com/...).
  string uri = 2;
  // Optional scoping fields for clarity/tools.
  string project  = 3;
  string location = 4;
  string key_ring = 5;
  string key_name = 6;
  string version  = 7;
  // For Vault: mount path/engine name.
  string vault_mount = 8;
}

// Rotation/retention policy.
message RotationPolicy {
  // Rotate after this period from last rotation or creation.
  google.protobuf.Duration rotate_after = 1;
  // Grace window to prepare consumers (soft rollout).
  google.protobuf.Duration rotation_window = 2;
  // Enforce at most N enabled versions.
  int32 max_enabled_versions = 3;
  // Schedule and next planned rotation.
  string cron_schedule = 4;
  google.protobuf.Timestamp next_rotation_time = 5;
  // Retention of disabled/destroyed metadata.
  google.protobuf.Duration retain_metadata_for = 6;
}

// Replication policy for multi-region durability/compliance.
message ReplicationPolicy {
  enum Mode {
    MODE_UNSPECIFIED = 0;
    MODE_AUTOMATIC   = 1; // provider auto placement
    MODE_USER_MANAGED = 2; // explicit locations
  }
  Mode mode = 1;

  message Location {
    string location = 1; // e.g., "eu-north1"
    KmsKeyRef kms    = 2; // optional per-location key
  }
  repeated Location locations = 2;
}

// Integrity digests.
message Digest {
  bytes sha256      = 1;
  bytes sha512      = 2;
  bytes blake2b_256 = 3;
}

// Inline access policy (RBAC + conditions).
message AccessPolicy {
  message Binding {
    Role role = 1;
    // Principal can be user/serviceaccount/group; format arbitrary but consistent (e.g., "user:alice@example.com").
    repeated string principals = 2;
    // Conditional access.
    message Condition {
      // CEL expression (optional) for advanced policies.
      string cel_expression = 1;
      // Simple structured conditions (evaluated before CEL).
      repeated string ip_allow_subnets = 2;
      bool mfa_required = 3;
      // Time windows in which access is allowed (cron or RFC3339 intervals).
      repeated string time_windows = 4;
      // Require presence of these secret labels with exact values.
      map<string, string> required_secret_labels = 5;
    }
    Condition condition = 3;
  }
  repeated Binding bindings = 1;
  // Breakglass principals (audited).
  repeated string breakglass_principals = 2;
}

// ---------------------------
// Payload wrappers for RPCs
// ---------------------------

message SecretPayload {
  bytes data = 1;                 // plaintext for create/put (transport must be TLS/mTLS)
  string content_type = 2;
  Compression compression = 3;
  int32 compression_level = 4;    // optional hint
  Digest checksum = 5;            // sha256 of plaintext for end-to-end integrity
  // Optional override of crypto settings for this version only.
  EncryptionAlgorithm encryption_override = 6;
  KmsKeyRef kms_override = 7;
}

// ---------------------------
// Requests / Responses
// ---------------------------

message CreateSecretRequest {
  // Parent: projects/{project}/locations/{location}
  string parent = 1 [(google.api.field_behavior) = REQUIRED];
  string secret_id = 2 [(google.api.field_behavior) = REQUIRED];
  Secret secret = 3 [(google.api.field_behavior) = REQUIRED];
  // Optionally create initial version in a single transaction.
  SecretPayload initial_version = 4;
}

message CreateSecretResponse {
  Secret secret = 1;
  // Present if initial_version was set.
  SecretVersion version = 2;
}

message GetSecretRequest {
  string name = 1 [(google.api.field_behavior) = REQUIRED]; // Secret name
}

message ListSecretsRequest {
  string parent = 1 [(google.api.field_behavior) = REQUIRED];
  int32 page_size = 2;
  string page_token = 3;
  // Simple filter language: e.g., "labels.env=prod state=ACTIVE"
  string filter = 4;
}

message ListSecretsResponse {
  repeated Secret secrets = 1;
  string next_page_token = 2;
}

message UpdateSecretMetadataRequest {
  Secret secret = 1 [(google.api.field_behavior) = REQUIRED];
  google.protobuf.FieldMask update_mask = 2 [(google.api.field_behavior) = REQUIRED];
  // Use etag to avoid lost updates.
  string etag = 3;
}

message DeleteSecretRequest {
  string name = 1 [(google.api.field_behavior) = REQUIRED];
  // If set, deletion is scheduled and not immediate.
  bool schedule_destruction = 2;
}

message DisableSecretRequest { string name = 1 [(google.api.field_behavior) = REQUIRED]; }
message EnableSecretRequest  { string name = 1 [(google.api.field_behavior) = REQUIRED]; }

message PutSecretVersionRequest {
  // Parent secret: projects/{project}/locations/{location}/secrets/{secret}
  string parent = 1 [(google.api.field_behavior) = REQUIRED];
  SecretPayload payload = 2 [(google.api.field_behavior) = REQUIRED];
  // Optional idempotency key for retries.
  string request_id = 3;
}

message SecretVersionName {
  string name = 1 [(google.api.field_behavior) = REQUIRED];
}

message ListSecretVersionsRequest {
  string parent = 1 [(google.api.field_behavior) = REQUIRED]; // secret name
  int32 page_size = 2;
  string page_token = 3;
  string filter = 4; // e.g., "state=ENABLED"
}

message ListSecretVersionsResponse {
  repeated SecretVersion versions = 1;
  string next_page_token = 2;
}

message AccessSecretVersionRequest {
  // projects/{project}/locations/{location}/secrets/{secret}/versions/{version}
  string name = 1 [(google.api.field_behavior) = REQUIRED];
  // Reason for access (audited).
  string reason = 2;
  // Arbitrary audit context (e.g., ticket ID).
  map<string, string> audit_context = 3;
}

message AccessSecretVersionResponse {
  bytes data = 1; // plaintext (transport must be TLS/mTLS; consider additional app-level crypto if required)
  string content_type = 2;
  Compression compression = 3;
  Digest checksum = 4; // checksum of plaintext
  string etag = 5;
  EncryptionEnvelope envelope = 6; // metadata of stored version
}

message SetAccessPolicyRequest {
  string name = 1 [(google.api.field_behavior) = REQUIRED]; // secret name
  AccessPolicy policy = 2 [(google.api.field_behavior) = REQUIRED];
  string etag = 3;
}

message GetAccessPolicyRequest {
  string name = 1 [(google.api.field_behavior) = REQUIRED];
}

message DisableSecretVersionRequest { string name = 1 [(google.api.field_behavior) = REQUIRED]; }
message EnableSecretVersionRequest  { string name = 1 [(google.api.field_behavior) = REQUIRED]; }

message DestroySecretVersionRequest {
  string name = 1 [(google.api.field_behavior) = REQUIRED];
  bool allow_recoverable = 2; // if false -> hard destroy
}

message AccessDecision {
  bool allow = 1;
  string matched_rule = 2;
  repeated DenyReason deny_reasons = 3;
}

message SecretEvent {
  string resource = 1; // secret or version name
  AuditAction action = 2;
  google.protobuf.Timestamp event_time = 3;
  string actor = 4;
  string source_ip = 5;
  string user_agent = 6;
  bool mfa = 7;
  AccessDecision decision = 8;
  map<string, string> labels = 9;
  map<string, string> context = 10;
}

// ---------------------------
// Service
// ---------------------------

service SecretsService {
  rpc CreateSecret(CreateSecretRequest) returns (CreateSecretResponse) {
    option (google.api.http) = {
      post: "/v1/{parent=projects/*/locations/*}/secrets"
      body: "secret"
    };
  }

  rpc GetSecret(GetSecretRequest) returns (Secret) {
    option (google.api.http) = {
      get: "/v1/{name=projects/*/locations/*/secrets/*}"
    };
  }

  rpc ListSecrets(ListSecretsRequest) returns (ListSecretsResponse) {
    option (google.api.http) = {
      get: "/v1/{parent=projects/*/locations/*}/secrets"
    };
  }

  rpc UpdateSecretMetadata(UpdateSecretMetadataRequest) returns (Secret) {
    option (google.api.http) = {
      patch: "/v1/{secret.name=projects/*/locations/*/secrets/*}"
      body: "secret"
    };
  }

  rpc DeleteSecret(DeleteSecretRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v1/{name=projects/*/locations/*/secrets/*}"
    };
  }

  rpc DisableSecret(DisableSecretRequest) returns (Secret) {
    option (google.api.http) = {
      post: "/v1/{name=projects/*/locations/*/secrets/*}:disable"
      body: "*"
    };
  }

  rpc EnableSecret(EnableSecretRequest) returns (Secret) {
    option (google.api.http) = {
      post: "/v1/{name=projects/*/locations/*/secrets/*}:enable"
      body: "*"
    };
  }

  rpc PutSecretVersion(PutSecretVersionRequest) returns (SecretVersion) {
    option (google.api.http) = {
      post: "/v1/{parent=projects/*/locations/*/secrets/*}/versions"
      body: "payload"
    };
  }

  rpc GetSecretVersion(SecretVersionName) returns (SecretVersion) {
    option (google.api.http) = {
      get: "/v1/{name=projects/*/locations/*/secrets/*/versions/*}"
    };
  }

  rpc ListSecretVersions(ListSecretVersionsRequest) returns (ListSecretVersionsResponse) {
    option (google.api.http) = {
      get: "/v1/{parent=projects/*/locations/*/secrets/*}/versions"
    };
  }

  rpc DisableSecretVersion(DisableSecretVersionRequest) returns (SecretVersion) {
    option (google.api.http) = {
      post: "/v1/{name=projects/*/locations/*/secrets/*/versions/*}:disable"
      body: "*"
    };
  }

  rpc EnableSecretVersion(EnableSecretVersionRequest) returns (SecretVersion) {
    option (google.api.http) = {
      post: "/v1/{name=projects/*/locations/*/secrets/*/versions/*}:enable"
      body: "*"
    };
  }

  rpc DestroySecretVersion(DestroySecretVersionRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/v1/{name=projects/*/locations/*/secrets/*/versions/*}:destroy"
      body: "*"
    };
  }

  rpc AccessSecretVersion(AccessSecretVersionRequest) returns (AccessSecretVersionResponse) {
    option (google.api.http) = {
      post: "/v1/{name=projects/*/locations/*/secrets/*/versions/*}:access"
      body: "*"
    };
  }

  rpc SetAccessPolicy(SetAccessPolicyRequest) returns (AccessPolicy) {
    option (google.api.http) = {
      post: "/v1/{name=projects/*/locations/*/secrets/*}:setAccessPolicy"
      body: "policy"
    };
  }

  rpc GetAccessPolicy(GetAccessPolicyRequest) returns (AccessPolicy) {
    option (google.api.http) = {
      get: "/v1/{name=projects/*/locations/*/secrets/*}:getAccessPolicy"
    };
  }
}
