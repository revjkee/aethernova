# cybersecurity-core/ops/helm/cybersecurity-core/values.yaml
# Промышленные значения по умолчанию. Все блоки опциональны и могут быть переопределены через --set/-f.

kubeVersion: ""

global:
  nameOverride: ""
  fullnameOverride: ""
  imagePullSecrets: [] # пример: [{ name: regcred }]
  priorityClassName: "" # пример: system-cluster-critical

controller:
  kind: Deployment # Deployment | StatefulSet | DaemonSet
  revisionHistoryLimit: 10
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 0
      maxSurge: 25%

replicaCount: 2

image:
  repository: ghcr.io/aethernova/cybersecurity-core
  tag: ""             # по умолчанию использует .Chart.AppVersion
  digest: ""          # если указан digest, tag игнорируется
  pullPolicy: IfNotPresent

serviceAccount:
  create: true
  name: ""
  automountServiceAccountToken: false
  annotations: {}

rbac:
  create: true
  # при необходимости добавить дополнительные правила
  extraRules: []
  # пример:
  # extraRules:
  #   - apiGroups: [""]
  #     resources: ["configmaps"]
  #     verbs: ["get","list","watch"]

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 65532
  runAsGroup: 65532
  fsGroup: 65532
  fsGroupChangePolicy: OnRootMismatch
  seccompProfile:
    type: RuntimeDefault
  supplementalGroups: []
  sysctls: [] # пример: [{ name: net.ipv4.tcp_fin_timeout, value: "15" }]

securityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  capabilities:
    drop: ["ALL"]
    add: []
  privileged: false

service:
  enabled: true
  type: ClusterIP # ClusterIP | NodePort | LoadBalancer
  annotations: {}
  labels: {}
  ports:
    http:
      enabled: true
      port: 80
      targetPort: 8080
      protocol: TCP
      name: http
    metrics:
      enabled: true
      port: 9090
      targetPort: 9090
      protocol: TCP
      name: metrics
  # для LoadBalancer
  loadBalancerIP: ""
  externalTrafficPolicy: Cluster
  sessionAffinity: None

ingress:
  enabled: false
  className: "nginx"
  annotations:
    kubernetes.io/tls-acme: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-production"
  hosts:
    - host: app.example.com
      paths:
        - path: /
          pathType: Prefix
          servicePort: http
  tls:
    - secretName: cybersecurity-core-tls
      hosts:
        - app.example.com

resources:
  requests:
    cpu: "200m"
    memory: "256Mi"
    ephemeral-storage: "256Mi"
  limits:
    cpu: "1"
    memory: "512Mi"
    ephemeral-storage: "1Gi"

autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 10
  # HPA v2
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 75
  behavior:
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
        - type: Percent
          value: 100
          periodSeconds: 60
      selectPolicy: Max
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
        - type: Percent
          value: 50
          periodSeconds: 60
      selectPolicy: Min

pdb:
  enabled: true
  minAvailable: 1
  # или:
  # maxUnavailable: 0

networkPolicy:
  enabled: true
  annotations: {}
  # Разрешаем вход только с namespaceSelector по метке или из кластера по умолчанию
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              network-policy: allow-apps
        - podSelector: {} # локальный namespace
      ports:
        - port: 80
          protocol: TCP
        - port: 9090
          protocol: TCP
  egress:
    - to:
        - namespaceSelector: {}
      ports:
        - port: 53
          protocol: UDP
        - port: 443
          protocol: TCP
        - port: 80
          protocol: TCP
  policyTypes:
    - Ingress
    - Egress

topology:
  podAntiAffinity:
    type: preferred # required | preferred | disabled
  topologySpreadConstraints:
    enabled: true
    constraints:
      - maxSkew: 1
        topologyKey: topology.kubernetes.io/zone
        whenUnsatisfiable: ScheduleAnyway
        labelSelector: {} # контролируется чартом через matchLabels

nodeSelector: {}
tolerations: []
affinity: {}

dnsPolicy: ClusterFirst
dnsConfig: {}
schedulerName: ""

terminationGracePeriodSeconds: 30

lifecycle:
  preStop:
    enabled: true
    command: ["/bin/sh","-c","sleep 5"]

env:
  - name: TZ
    value: UTC
  - name: LOG_LEVEL
    value: info
  - name: APP_HEALTH_PATH
    value: /healthz
  - name: APP_PORT
    value: "8080"

envFrom: []
# примеры:
# envFrom:
#   - configMapRef: { name: cybersecurity-core-config }
#   - secretRef:    { name: cybersecurity-core-secret, optional: true }

args: []     # пример: ["--mode=server"]
command: []  # пример: ["/bin/sh","-c","python -m cybersecurity_core"]

containerPorts:
  http: 8080
  metrics: 9090

probes:
  startup:
    enabled: true
    type: http # http | tcp | command
    httpGet:
      path: /healthz
      port: http
    initialDelaySeconds: 0
    periodSeconds: 5
    timeoutSeconds: 2
    failureThreshold: 30
  liveness:
    enabled: true
    type: http
    httpGet:
      path: /healthz
      port: http
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 2
    failureThreshold: 3
  readiness:
    enabled: true
    type: http
    httpGet:
      path: /healthz
      port: http
    initialDelaySeconds: 3
    periodSeconds: 5
    timeoutSeconds: 2
    failureThreshold: 3

logging:
  format: json
  level: info
  extra: {}

otel:
  enabled: false
  exporter: otlp
  endpoint: "http://otel-collector:4317"
  headers: {}
  samplingRatio: 1.0

metrics:
  enabled: true
  serviceMonitor:
    enabled: true
    interval: 30s
    scrapeTimeout: 10s
    scheme: http
    tlsConfig: {}
    labels: {}
    relabelings: []
    metricRelabelings: []
  podMonitor:
    enabled: false
  prometheusRule:
    enabled: true
    groups:
      - name: cybersecurity-core.rules
        rules:
          - alert: CybersecurityCoreHighErrorRate
            expr: sum(rate(http_server_requests_seconds_count{status=~"5.."}[5m])) by (service) / sum(rate(http_server_requests_seconds_count[5m])) by (service) > 0.05
            for: 10m
            labels:
              severity: warning
            annotations:
              summary: Высокая доля 5xx ответов
          - alert: CybersecurityCoreHighLatencyP95
            expr: histogram_quantile(0.95, sum(rate(http_server_requests_seconds_bucket[5m])) by (le)) > 0.5
            for: 10m
            labels:
              severity: warning
            annotations:
              summary: Перцентиль P95 выше порога

grafanaDashboards:
  enabled: false
  labels: {}
  # dashboards: {} # можно положить JSON-дашборды

serviceMesh:
  istio:
    enabled: false
    annotations: {}
    labels: {}
    trafficPolicy: {}
  linkerd:
    enabled: false
    annotations:
      linkerd.io/inject: "enabled"

persistence:
  enabled: false
  existingClaim: ""
  storageClass: ""
  accessModes: ["ReadWriteOnce"]
  size: 1Gi
  annotations: {}
  subPath: ""
  mountPath: /data

extraVolumes: []
extraVolumeMounts: []
# примеры:
# extraVolumes:
#   - name: tmp
#     emptyDir: { medium: Memory, sizeLimit: "256Mi" }
# extraVolumeMounts:
#   - name: tmp
#     mountPath: /tmp

config:
  enabled: true
  annotations: {}
  data:
    app-config.yaml: |
      server:
        port: 8080
        health_path: /healthz
      logging:
        level: info

secret:
  enabled: false
  annotations: {}
  stringData:
    DATABASE_URL: ""
    REDIS_URL: ""

externalSecrets:
  enabled: false
  refreshInterval: 1h
  backendType: secretsManager
  spec: {}
  # пример для ExternalSecrets Operator:
  # spec:
  #   secretStoreRef:
  #     kind: ClusterSecretStore
  #     name: aws-secrets
  #   target:
  #     name: cybersecurity-core-secret
  #     creationPolicy: Owner
  #   data:
  #     - secretKey: DATABASE_URL
  #       remoteRef:
  #         key: prod/cybersecurity-core
  #         property: DATABASE_URL

secretsStoreCsi:
  enabled: false
  provider: "" # azure, gcp, aws, vault
  parameters: {}
  files: []
  # пример:
  # files:
  #   - path: /mnt/secrets/db
  #     objectName: db-conn

sidecars:
  enabled: false
  containers: []
  # примеры готовых профилей:
  profiles:
    vector:
      enabled: false
      image: timberio/vector:0.42.0-debian
      resources: {}
      config: |
        sources:
          app_logs:
            type: file
            include: ["/var/log/app/*.log"]
        sinks:
          stdout:
            type: console
            inputs: [app_logs]
            encoding:
              codec: json
    fluentBit:
      enabled: false
      image: cr.fluentbit.io/fluent/fluent-bit:3.0
      resources: {}
      config: |
        [SERVICE]
            Daemon Off
            Log_Level info
        [INPUT]
            Name tail
            Path /var/log/app/*.log
        [OUTPUT]
            Name stdout
            Match *

initContainers: []
# пример:
# initContainers:
#   - name: wait-db
#     image: busybox:1.36
#     command: ["sh","-c","until nc -z db 5432; do sleep 2; done"]

extraContainers: []

podAnnotations: {}
podLabels: {}

extraEnvFrom: [] # альтернативный список envFrom для sidecars и т.д.

extraArgs: []
extraCommand: []

hostAliases: []
# - ip: "127.0.0.1"
#   hostnames: ["local.test"]

serviceAccountAnnotations: {}

# Автоматическая подстановка checksum аннотаций для перезапуска подов при изменении ConfigMap/Secret
checksums:
  config: true
  secret: true

certManager:
  enabled: false
  clusterIssuer: letsencrypt-production
  dnsNames: []
  secretName: cybersecurity-core-tls

imagePullSecretsGlobal: [] # дублирующий удобный ключ

readinessGate: []
# пример: [{ conditionType: "target-health.alb.ingress.k8s.aws/health" }]

podDisruptionBudget:
  usePolicyAPI: true # использовать policy/v1, если доступно

priority:
  enabled: false
  className: ""

# Управление логическими портами приложения
ports:
  exposeMetrics: true

# Политика монтирования сервис-аккаунта
automountServiceAccountToken: false

# Ограничение PID и других лимитов можно вынести в SecurityContext или Annotations (зависит от кластера)
limits:
  pids: 256

# Доп. параметры для контейнера с приложением
app:
  # По умолчанию чарт использует образ, команду/аргументы из values.command/args
  # Здесь можно задать специфичные флаги приложения
  extraFlags: []
