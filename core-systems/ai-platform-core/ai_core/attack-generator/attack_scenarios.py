import json
import random
import uuid
import logging
from datetime import datetime, timedelta
from typing import List, Dict, Optional

# === TeslaAI Adversarial Scenario Generator v3.0 ===
# Agents: PatternGenerator, TTPMapper, ScenarioMutator, SignatureInjector,
# RedTeamPlanner, RiskScorer, OutputExporter, ChainComposer, TargetClassifier,
# IOCEmbedder, EnvironmentBinder, AttackExpander, TimingRandomizer,
# DeceptionBypasser, RedTagger, C2VariantSelector, TraceLinker, MITREConnector,
# ScenarioHasher, ValidatorAgent
# MetaGenerals: Architectus, Evolver, Guardian

logger = logging.getLogger("attack_scenarios")
logger.setLevel(logging.INFO)

MITRE_TTP_LIBRARY = {
    "network_scan": {"id": "T1046", "risk": "medium", "desc": "Network service scanning"},
    "unauthorized_access": {"id": "T1078", "risk": "high", "desc": "Valid account abuse"},
    "data_exfiltration": {"id": "T1041", "risk": "high", "desc": "Exfiltration over C2 channel"},
    "lateral_movement": {"id": "T1021", "risk": "high", "desc": "Remote service usage"},
    "ransomware_payload": {"id": "T1486", "risk": "critical", "desc": "Encrypting file system"},
    "custom_script": {"id": "T1059", "risk": "variable", "desc": "Scripted execution"},
    "c2_communication": {"id": "T1105", "risk": "medium", "desc": "Inbound C2 via HTTP/HTTPS"},
    "privilege_escalation": {"id": "T1068", "risk": "high", "desc": "Exploitation for privilege escalation"},
}


class AttackScenarioGenerator:
    def __init__(self, seed: Optional[int] = None):
        self.random = random.Random(seed)

    def generate_attack_chain(
        self,
        target: str,
        chain_length: int = 5,
        start_time: Optional[datetime] = None,
        risk_profile: Optional[str] = "mixed",
    ) -> List[Dict]:
        logger.info(f"Generating attack chain for target: {target}")
        scenario = []
        time_cursor = start_time or datetime.utcnow()

        for i in range(chain_length):
            action = self._select_ttp(risk_profile)
            event = self._generate_event(action, target, time_cursor)
            scenario.append(event)
            time_cursor += timedelta(seconds=self.random.randint(30, 180))

        return scenario

    def _select_ttp(self, risk_profile: str) -> str:
        if risk_profile == "high":
            pool = [k for k, v in MITRE_TTP_LIBRARY.items() if v["risk"] in {"high", "critical"}]
        elif risk_profile == "low":
            pool = [k for k, v in MITRE_TTP_LIBRARY.items() if v["risk"] == "medium"]
        else:
            pool = list(MITRE_TTP_LIBRARY.keys())

        selected = self.random.choice(pool)
        logger.debug(f"Selected TTP: {selected}")
        return selected

    def _generate_event(self, action: str, target: str, timestamp: datetime) -> Dict:
        ttp = MITRE_TTP_LIBRARY.get(action, {})
        return {
            "event_id": str(uuid.uuid4()),
            "timestamp": timestamp.isoformat(),
            "action": action,
            "target": target,
            "source": "attack_generator",
            "mitre_id": ttp.get("id", "T0000"),
            "risk_level": ttp.get("risk", "low"),
            "description": ttp.get("desc", "Unknown tactic"),
            "meta": {
                "ioc": self._generate_ioc(action),
                "notes": "Auto-generated by TeslaAI Agent",
            },
        }

    def _generate_ioc(self, action: str) -> Dict:
        if action == "c2_communication":
            return {"ip": f"192.168.{self.random.randint(0,255)}.{self.random.randint(1,254)}", "port": self.random.choice([80, 443, 8080])}
        elif action == "custom_script":
            return {"script": "echo malicious_command > /tmp/pwned.sh"}
        elif action == "ransomware_payload":
            return {"file": f"/home/user/{uuid.uuid4().hex[:8]}.lock"}
        return {}

    def mutate_scenario(self, scenario: List[Dict], mutate_factor: float = 0.3) -> List[Dict]:
        logger.info("Mutating scenario...")
        mutated = []
        for event in scenario:
            if self.random.random() < mutate_factor:
                event["meta"]["mutation"] = "timing_shift"
                event["timestamp"] = (datetime.fromisoformat(event["timestamp"]) + timedelta(seconds=self.random.randint(-60, 60))).isoformat()
            mutated.append(event)
        return mutated

    def export_to_json(self, scenario: List[Dict], path: str):
        with open(path, "w") as f:
            json.dump(scenario, f, indent=2)
        logger.info(f"Scenario exported to: {path}")
