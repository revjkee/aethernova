# forgemind-core/exploit_forge/generative_mutator.py

import re
import uuid
import random
import logging
import hashlib
from typing import Dict, List, Optional

from z3 import Solver, BitVec, sat
from ast import parse, NodeTransformer, fix_missing_locations, Call, Name, Constant, AST
import astor

logger = logging.getLogger("generative_mutator")
logger.setLevel(logging.DEBUG)

class ExploitVariant:
    def __init__(self, code: str, uid: Optional[str] = None, score: float = 0.0):
        self.code = code
        self.uid = uid or str(uuid.uuid4())
        self.score = score
        self.hash = self._compute_hash()

    def _compute_hash(self) -> str:
        return hashlib.sha256(self.code.encode()).hexdigest()

    def to_dict(self) -> Dict:
        return {
            "uid": self.uid,
            "hash": self.hash,
            "score": self.score,
            "code": self.code
        }

class SemanticMutator(NodeTransformer):
    def visit_Call(self, node: Call) -> AST:
        if isinstance(node.func, Name) and node.func.id == "input":
            node.func.id = "raw_input"
        return self.generic_visit(node)

    def visit_Constant(self, node: Constant) -> AST:
        if isinstance(node.value, str):
            node.value = node.value[::-1]  # Reverse string literal
        return node

class ConstraintSolver:
    def __init__(self):
        self.solver = Solver()

    def satisfy_bitmask(self, desired_mask: int) -> Optional[int]:
        x = BitVec("x", 32)
        self.solver.push()
        self.solver.add((x & 0xFFFF00FF) == desired_mask)
        if self.solver.check() == sat:
            model = self.solver.model()
            val = model[x].as_long()
            self.solver.pop()
            return val
        self.solver.pop()
        return None

class GenerativeMutator:
    def __init__(self):
        self.history: Dict[str, ExploitVariant] = {}
        self.max_depth = 3
        self.constraint_solver = ConstraintSolver()

    def mutate_exploit(self, base_code: str) -> ExploitVariant:
        try:
            tree = parse(base_code)
            transformer = SemanticMutator()
            mutated_tree = transformer.visit(tree)
            fixed_tree = fix_missing_locations(mutated_tree)
            new_code = astor.to_source(fixed_tree)
        except Exception as e:
            logger.error(f"[MUTATOR] AST error: {e}")
            new_code = self._fallback_mutation(base_code)

        variant = ExploitVariant(code=new_code)
        self.history[variant.uid] = variant
        logger.info(f"[MUTATOR] Variant {variant.uid} generated")
        return variant

    def _fallback_mutation(self, code: str) -> str:
        replacements = {
            "eval(": "exec(",
            "input(": "raw_input(",
            "127.0.0.1": "localhost",
        }
        for k, v in replacements.items():
            code = code.replace(k, v)
        return code

    def morph_shellcode(self, shellcode: bytes) -> bytes:
        xor_key = random.randint(1, 255)
        mutated = bytes([b ^ xor_key for b in shellcode])
        logger.debug(f"[SHELLCODE] Applied XOR key: {xor_key}")
        return mutated

    def apply_z3_constraint(self, mask: int) -> Optional[int]:
        return self.constraint_solver.satisfy_bitmask(mask)

    def score_variant(self, variant: ExploitVariant, metrics: Dict[str, float]) -> None:
        weight = {"obfuscation": 0.4, "length": 0.3, "uniqueness": 0.3}
        score = sum(metrics[k] * w for k, w in weight.items() if k in metrics)
        variant.score = round(score, 4)
        self.history[variant.uid] = variant
        logger.info(f"[SCORE] {variant.uid} â†’ {variant.score}")

    def export_all(self) -> List[Dict]:
        return [v.to_dict() for v in self.history.values()]
