import logging
from typing import List, Dict, Optional

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

class ExploitSelector:
    """
    Класс для выбора наиболее подходящих эксплойтов на основе критериев целевой системы.
    """

    def __init__(self, exploits_db: List[Dict[str, any]]):
        """
        Инициализация селектора с базой данных эксплойтов.

        :param exploits_db: список эксплойтов, каждый — словарь с атрибутами (name, os, service, severity и др.)
        """
        self.exploits_db = exploits_db
        logger.debug(f"ExploitSelector инициализирован с {len(exploits_db)} эксплойтами.")

    def select(self, target_info: Dict[str, str], severity_threshold: int = 5) -> List[Dict[str, any]]:
        """
        Выбрать эксплойты, подходящие под характеристики цели и заданный порог серьезности.

        :param target_info: информация о цели, например {'os': 'linux', 'service': 'ssh', 'version': '7.2'}
        :param severity_threshold: минимальный уровень серьезности эксплойта (1-10)
        :return: список подходящих эксплойтов
        """
        selected = []
        for exploit in self.exploits_db:
            if not self._match_exploit(exploit, target_info):
                continue
            if exploit.get('severity', 0) < severity_threshold:
                continue
            selected.append(exploit)
        logger.debug(f"Выбрано {len(selected)} эксплойтов для цели {target_info}")
        return selected

    def _match_exploit(self, exploit: Dict[str, any], target_info: Dict[str, str]) -> bool:
        """
        Проверить соответствие эксплойта характеристикам цели.

        :param exploit: словарь с атрибутами эксплойта
        :param target_info: словарь с атрибутами цели
        :return: True, если эксплойт подходит
        """
        # Проверяем ОС
        if 'os' in exploit and exploit['os'].lower() != target_info.get('os', '').lower():
            return False
        # Проверяем сервис
        if 'service' in exploit and exploit['service'].lower() != target_info.get('service', '').lower():
            return False
        # Можно расширить логику: версия, архитектура и др.
        return True

    def best_exploit(self, target_info: Dict[str, str]) -> Optional[Dict[str, any]]:
        """
        Вернуть самый серьёзный (по severity) эксплойт для цели.

        :param target_info: характеристики цели
        :return: словарь с данными эксплойта или None
        """
        candidates = self.select(target_info)
        if not candidates:
            logger.debug("Подходящих эксплойтов не найдено.")
            return None
        best = max(candidates, key=lambda x: x.get('severity', 0))
        logger.debug(f"Лучший эксплойт выбран: {best.get('name')}")
        return best
