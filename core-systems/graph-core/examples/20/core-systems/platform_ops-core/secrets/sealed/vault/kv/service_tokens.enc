#!/bin/bash
set -euo pipefail

# Конфигурация Vault
VAULT_ADDR="https://vault.example.com"
VAULT_TOKEN_FILE="$HOME/.vault-token"
TRANSIT_KEY="service-tokens-key"
PLAIN_FILE="service_tokens.json"
ENC_FILE="service_tokens.enc"

# Проверяем токен Vault
if [[ ! -f "$VAULT_TOKEN_FILE" ]]; then
  echo "Vault token file not found: $VAULT_TOKEN_FILE"
  exit 1
fi

VAULT_TOKEN=$(cat "$VAULT_TOKEN_FILE")

# Пример JSON с access токенами сервисов (заменить на реальные данные)
cat > "$PLAIN_FILE" << EOF
{
  "github_token": "ghp_exampletoken1234567890",
  "slack_token": "xoxb-example-token",
  "aws_session_token": "FQoGZXIvYXdzE..."
}
EOF

# Шифрование с помощью Vault Transit API
ENC_RESULT=$(curl -s --header "X-Vault-Token: $VAULT_TOKEN" \
  --request POST \
  --data "{\"plaintext\":\"$(base64 -w0 $PLAIN_FILE)\"}" \
  "$VAULT_ADDR/v1/transit/encrypt/$TRANSIT_KEY")

# Получаем ciphertext
CIPHER_TEXT=$(echo "$ENC_RESULT" | jq -r '.data.ciphertext')

if [[ -z "$CIPHER_TEXT" || "$CIPHER_TEXT" == "null" ]]; then
  echo "Encryption failed. Vault response:"
  echo "$ENC_RESULT"
  exit 1
fi

# Сохраняем зашифрованный токен в файл
echo "$CIPHER_TEXT" > "$ENC_FILE"

# Удаляем исходный файл
rm -f "$PLAIN_FILE"

echo "Encrypted service tokens saved to $ENC_FILE"
