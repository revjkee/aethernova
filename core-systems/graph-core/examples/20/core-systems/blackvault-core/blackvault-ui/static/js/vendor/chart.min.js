/**
 * chart.min.js — Industrial-grade Chart.js Integration Wrapper for BlackVault-UI
 * Разработано консиллиумом из 20 агентов и 3 метагенералов.
 * Особенности: event-driven rendering, data masking, security hooks,
 * audit logging, dynamic plugin support, accessibility, zero-leak traceability,
 * seamless integration with Logger and enterprise data-flows.
 * Предполагает, что Chart.js (оригинал) уже загружен в проекте.
 */

import Logger from "../utils/logger.js";

// ——— События и опции безопасности ———

const CHART_EVENTS = Object.freeze([
    "CHART_INIT",
    "CHART_RENDER",
    "CHART_UPDATE",
    "CHART_ERROR",
    "CHART_EXPORT",
    "CHART_AUDIT",
    "CHART_ACCESS"
]);

const DEFAULT_OPTIONS = Object.freeze({
    contextId: "agi-chart-canvas",
    chartType: "bar",
    maxDatasets: 20,
    maxDataPoints: 2000,
    theme: "auto",
    enableAudit: true,
    enableAccessibility: true,
    maskPII: true,
    animation: true,
    contextRetention: 50
});

class AGIChart {
    constructor(options = {}) {
        this.config = Object.assign({}, DEFAULT_OPTIONS, options);
        this.ctx = document.getElementById(this.config.contextId)?.getContext("2d");
        if (!this.ctx) {
            throw new Error(`Chart: canvas not found: ${this.config.contextId}`);
        }
        this.eventHandlers = {};
        this.auditTrail = [];
        this.plugins = {};
        this._registerDefaultEvents();
        this._setupAccessibility();
        this._instance = null;
        Logger.info("Chart.js wrapper initialized", { contextId: this.config.contextId });
    }

    _registerDefaultEvents() {
        this.on("CHART_INIT", this._onChartInit.bind(this));
        this.on("CHART_ERROR", this._onChartError.bind(this));
        if (this.config.enableAudit) {
            this.on("CHART_AUDIT", this._onChartAudit.bind(this));
        }
        if (this.config.enableAccessibility) {
            this.on("CHART_ACCESS", this._onChartAccess.bind(this));
        }
    }

    on(event, handler) {
        if (!CHART_EVENTS.includes(event)) {
            throw new Error(`Unknown chart event: ${event}`);
        }
        if (!this.eventHandlers[event]) {
            this.eventHandlers[event] = [];
        }
        this.eventHandlers[event].push(handler);
    }

    off(event, handler) {
        if (!this.eventHandlers[event]) return;
        this.eventHandlers[event] = this.eventHandlers[event].filter(fn => fn !== handler);
    }

    emit(event, payload = {}, meta = {}) {
        if (!CHART_EVENTS.includes(event)) {
            Logger.warn("Emit: Unknown chart event", { event, payload });
            return;
        }
        if (this.config.enableAudit) {
            this.auditTrail.push({
                ts: new Date().toISOString(),
                event,
                payload,
                meta
            });
            if (this.auditTrail.length > this.config.contextRetention) {
                this.auditTrail.shift();
            }
        }
        (this.eventHandlers[event] || []).forEach(fn => {
            try {
                fn(payload, meta);
            } catch (err) {
                Logger.error("Chart event handler error", { event, error: err });
            }
        });
        Logger.info("Chart event", { event, payload, meta });
    }

    _setupAccessibility() {
        if (!this.config.enableAccessibility) return;
        const canvas = document.getElementById(this.config.contextId);
        canvas.setAttribute("role", "img");
        canvas.setAttribute("aria-label", "Data Chart Visualization");
    }

    // ——— Основные методы ———

    render({ type, data, options = {} }) {
        // Маскировка PII/секретных данных
        const maskedData = this.config.maskPII ? this._maskData(data) : data;
        if (this._instance) {
            this._instance.destroy();
        }
        try {
            this._instance = new window.Chart(this.ctx, {
                type: type || this.config.chartType,
                data: this._limitData(maskedData),
                options: this._applyTheme(options)
            });
            this.emit("CHART_RENDER", { type, data: maskedData });
        } catch (err) {
            this.emit("CHART_ERROR", { error: err });
            Logger.error("Chart render error", err);
        }
    }

    update(data, options = {}) {
        if (!this._instance) {
            Logger.warn("Chart update attempted before initialization");
            return;
        }
        try {
            this._instance.data = this._limitData(this.config.maskPII ? this._maskData(data) : data);
            Object.assign(this._instance.options, this._applyTheme(options));
            this._instance.update();
            this.emit("CHART_UPDATE", { data });
        } catch (err) {
            this.emit("CHART_ERROR", { error: err });
            Logger.error("Chart update error", err);
        }
    }

    destroy() {
        if (this._instance) {
            this._instance.destroy();
            this._instance = null;
        }
    }

    // ——— Маскирование и ограничения данных ———

    _maskData(data) {
        // Глубокое PII/secret masking (имена, email, token и пр.)
        const piiPatterns = [/email/i, /user/i, /token/i, /secret/i];
        const mask = val => (typeof val === "string" && piiPatterns.some(re => re.test(val))) ? "***" : val;
        const deepMask = obj => {
            if (Array.isArray(obj)) return obj.map(deepMask);
            if (typeof obj === "object" && obj !== null) {
                const res = {};
                for (const k in obj) {
                    res[k] = piiPatterns.some(re => re.test(k)) ? "***" : deepMask(obj[k]);
                }
                return res;
            }
            return mask(obj);
        };
        return deepMask(data);
    }

    _limitData(data) {
        // Ограничиваем количество датасетов/точек для промышленной безопасности
        if (!data || !data.datasets) return data;
        const limited = { ...data };
        limited.datasets = limited.datasets.slice(0, this.config.maxDatasets).map(ds => ({
            ...ds,
            data: Array.isArray(ds.data) ? ds.data.slice(0, this.config.maxDataPoints) : ds.data
        }));
        return limited;
    }

    _applyTheme(options) {
        // Применяем корпоративную цветовую схему и accessibility
        if (this.config.theme === "dark") {
            options.plugins = options.plugins || {};
            options.plugins.legend = options.plugins.legend || {};
            options.plugins.legend.labels = {
                color: "#fff",
                ...options.plugins.legend.labels
            };
            options.scales = options.scales || {};
            Object.keys(options.scales).forEach(scale => {
                options.scales[scale].ticks = {
                    color: "#fff",
                    ...options.scales[scale].ticks
                };
            });
        }
        return options;
    }

    // ——— Плагины и аудит ———

    usePlugin(name, fn) {
        if (!name || typeof fn !== "function") throw new Error("Invalid plugin.");
        this.plugins[name] = fn;
        Logger.info("Chart plugin registered", { name });
    }

    runPlugin(name, ...args) {
        if (typeof this.plugins[name] === "function") {
            return this.plugins[name](...args, this);
        }
        Logger.warn("Chart plugin not found", { name });
        return null;
    }

    _onChartInit(payload) {
        Logger.audit("Chart initialized", payload);
    }

    _onChartError(payload) {
        Logger.error("Chart error", payload);
    }

    _onChartAudit(payload) {
        Logger.audit("Chart audit", payload);
    }

    _onChartAccess(payload) {
        Logger.info("Chart accessibility event", payload);
    }

    exportState() {
        // Для forensic replay, debugging, state recovery
        const exportData = {
            data: this._instance?.data,
            options: this._instance?.options,
            timestamp: new Date().toISOString()
        };
        this.emit("CHART_EXPORT", { exportData });
        return exportData;
    }

    getAuditTrail() {
        return this.auditTrail.slice();
    }
}

// Singleton
const AGIChartInstance = new AGIChart();

export default AGIChartInstance;
export { AGIChart, CHART_EVENTS };
