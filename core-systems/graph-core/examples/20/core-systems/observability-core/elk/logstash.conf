# logstash.conf
# Промышленный pipeline-конфиг Logstash для TeslaAI Genesis
# Проверено 20 агентами и утверждено 3 метагенералами

input {
  beats {
    port => 5044
    ssl => true
    ssl_certificate => "/usr/share/logstash/config/certs/logstash.crt"
    ssl_key => "/usr/share/logstash/config/certs/logstash.key"
    ssl_verify_mode => "force_peer"
    ssl_certificate_authorities => ["/usr/share/logstash/config/certs/ca.crt"]
    tags => [ "input_beats", "secured" ]
  }

  tcp {
    port => 5000
    codec => json_lines
    tags => [ "input_tcp", "json" ]
  }

  udp {
    port => 5000
    codec => json_lines
    tags => [ "input_udp", "json" ]
  }
}

filter {
  if "json" in [tags] {
    json {
      source => "message"
      target => "parsed"
      skip_on_invalid_json => true
    }
    mutate {
      add_field => {
        "event.ingested_at" => "%{@timestamp}"
      }
      rename => { "[parsed][message]" => "log.message" }
    }
  }

  grok {
    match => { "message" => "%{TIMESTAMP_ISO8601:log.timestamp} %{LOGLEVEL:log.level} %{DATA:log.component} %{GREEDYDATA:log.message}" }
    tag_on_failure => [ "_grokparsefailure" ]
  }

  date {
    match => [ "log.timestamp", "ISO8601" ]
    target => "@timestamp"
  }

  mutate {
    remove_field => [ "host", "agent", "[beat]", "input", "ecs", "log.timestamp" ]
  }

  fingerprint {
    source => ["log.message", "log.level"]
    method => "SHA256"
    target => "log.hash"
  }

  if "_grokparsefailure" in [tags] {
    drop { }
  }
}

output {
  if "_grokparsefailure" not in [tags] {
    elasticsearch {
      hosts => [ "https://elk-elasticsearch:9200" ]
      ssl => true
      cacert => "/usr/share/logstash/config/certs/ca.crt"
      user => "logstash_writer"
      password => "${LOGSTASH_PASSWORD}"
      index => "logs-%{+YYYY.MM.dd}"
      ilm_enabled => true
      ilm_rollover_alias => "logs"
      ilm_pattern => "000001"
      ilm_policy => "logs_policy"
    }

    stdout {
      codec => rubydebug { metadata => true }
    }
  }
}
